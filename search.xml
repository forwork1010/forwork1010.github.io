<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Part4 跨站请求伪造</title>
      <link href="2020/10/15/part4-kua-zhan-qing-qiu-wei-zao/"/>
      <url>2020/10/15/part4-kua-zhan-qing-qiu-wei-zao/</url>
      
        <content type="html"><![CDATA[<h1 id="Part4-跨站请求伪造"><a href="#Part4-跨站请求伪造" class="headerlink" title="Part4 跨站请求伪造"></a><center>Part4 跨站请求伪造</center></h1><p> <font color="#A52A2A" size="4"><em>本文部分翻译自Peter Yaworski的《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>当攻击者可以使目标的浏览器将HTTP请求发送到另一个网站时，就会发生跨站点请求伪造（CSRF）攻击。该网站执行操作，就好像请求是由目标发送的。这种攻击通常依赖于目标，该目标先前已在易受攻击的网站上进行了身份验证，在该网站上提交了该操作，并且在目标不知情的情况下发生了该攻击。 CSRF攻击成功后，攻击者便能够修改服务器端信息，甚至可能接管用户的帐户。以下是其一个例子：</p><pre class="line-numbers language-none"><code class="language-none">Bob登录他的银行网站以检查他的余额。然后，Bob在另一个网站上查看他的电子邮件。这时，Bob收到一封电子邮件，其中包含指向不熟悉的网站的链接，他单击该链接以查看其链接。加载后，陌生的网站会指示Bob的浏览器向Bob的银行网站发出HTTP请求，以请求从他的帐户向攻击者的帐户转移资金。Bob的银行网站接收到来自陌生（恶意）网站的HTTP请求。但是，由于银行网站没有任何CSRF保护，因此可以处理转帐。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="认证（Authorization）"><a href="#认证（Authorization）" class="headerlink" title="认证（Authorization）"></a>认证（Authorization）</h2><p>就像我刚才描述的那样，CRSF攻击利用了网站用于验证请求的过程中的弱点。当您访问要求您登录的网站时，通常使用用户名和密码登录，该网站通常会对您进行身份验证。然后，该网站会将身份验证存储在您的浏览器中，因此您不必每次访问该网站上的新页面时都登录。</p><p>它可以通过两种方式存储身份验证：使用基本身份验证协议或cookie。</p><p>当HTTP请求包括如下标头时，您可以标识使用基本授权的站点：Authorization  ：Basic QWxhZGRpbjpPcGVuU2VzYW1l。看起来像随机的字符串实际上是用base64编码的用户名和密码，中间用冒号分隔。QWxhZGRpbjpPcGVuU2VzYW11l解码为Aladdin：OpenSesame。</p><p>Cookies是网站创建并存储在用户浏览器中的小文件。网站使用Cookie的目的多种多样，例如用于存储诸如用户偏好设置或用户访问网站的历史记录之类的信息。 Cookies具有某些属性，它们是标准化的信息。这些详细信息向浏览器介绍了cookie以及如何处理它们。一些Cookie属性可以包括domain，expires，max-age，secure onlyHTTP。除了属性外，Cookie还可以包含一个名称/值（name/value）对，它由一个标识符和一个相关值组成。</p><p>浏览器定义站点可以设置的cookie数量。但通常，单个站点在普通浏览器中可以设置50至150个cookie，据报道某些站点最多支持600个cookie。浏览器通常允许站点为每个cookie最多使用4KB。 Cookie名称或值没有标准：网站可以自由选择自己的名称/值对和用途。例如，网站可以使用名为sessionId的cookie来记住用户是谁，这样就无需让用户为他们访问的每个页面或执行的操作输入用户名和密码。 （回想一下，HTTP请求是无状态的，如第1章所述。无状态是指对于每个HTTP请求，网站都不知道用户是谁，因此它必须为每个请求重新验证该用户的身份。）</p><p>例如，cookie中的名称/值对可以是sessionId = 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08，并且cookie可以具有<code>.site.com</code>域。因此，sessionId cookie将被发送到用户访问的每个<code>.&lt;site&gt; .com</code>网站，例如<code>foo.&lt;site&gt; .com</code>，<code>bar.&lt;site&gt; .com</code>，<code>www.&lt;site&gt; .com</code>等。 。</p><p>secure和httponly属性告诉浏览器何时以及如何发送和读取cookie。这些属性不包含值。当cookie包含secure属性时，浏览器将仅在访问HTTPS站点时发送该cookie。例如，如果您使用secure的cookie访问<code>http：// www.&lt;site&gt; .com /</code>（HTTP站点），您的浏览器不会将cookie发送到该站点。原因是为了保护您的隐私，因为HTTPS连接是加密的，而HTTP连接不是加密的。httponly属性很重要，它告诉浏览器仅通过HTTP和HTTPS请求读取cookie。因此，浏览器将不允许任何脚本语言（例如JavaScript）读取该cookie的值。如果未在cookie中设置secure和httponly属性，则可以合法发送这些cookie，但会恶意读取。这将导致没有secure属性的cookie发送到非HTTPS站点，JavaScript可以读取未设置httponly的cookie。</p><p>expires和max-age属性指示cookie何时到期，何时浏览器应销毁它。 expires属性只是告诉浏览器在特定日期销毁cookie。例如，Cookie可以将属性设置为expires = Wed，18 Dec 2019 12:00:00 UTC。而max-age是指cookie过期之前的秒数，其格式为整数（max-age= 300）。</p><p>总而言之，如果Bob访问的银行网站使用Cookie，则该网站将通过以下过程存储其身份验证。Bob访问该网站并登录后，银行将使用HTTP响应来响应其HTTP请求，该HTTP响应包括一个标识Bob的cookie。鲍勃的浏览器将自动将该Cookie和所有其他HTTP请求一起发送到银行网站。</p><p>完成银行业务后，Bob离开银行网站时没有注销。请注意这个重要的细节，因为当您注销站点时，该站点通常会以HTTP响应来响应，该响应会使cookie过期。因此，当您重新访问该网站时，您将不得不再次登录。</p><p>当Bob查看电子邮件并单击链接访问未知网站时，表示他无意中访问了恶意网站。该网站旨在通过指示Bob的浏览器向其银行网站发出请求来进行CSRF攻击。该请求还会从他的浏览器发送cookie。</p><h2 id="CSRF与GET请求"><a href="#CSRF与GET请求" class="headerlink" title="CSRF与GET请求"></a>CSRF与GET请求</h2><p>恶意网站利用Bob的银行网站的方式取决于银行是否通过GET或POST请求接受转账。如果Bob的银行网站接受通过GET请求进行的转帐，则恶意网站将使用隐藏表格（hidden form）或<code>&lt;img&gt;</code>标签发送HTTP请求。 GET和POST方法都依靠HTML来使浏览器发送所需的HTTP请求，并且这两种方法都可以使用hidden form，但是只有GET方法可以使用<code>&lt;img&gt;</code>标记技术。在本节中，我们将研究使用GET请求方法时如何利用HTML<code> &lt;img&gt;</code>标记，并在下一节“CSRF与POST请求”中研究利用hidden form。</p><p>攻击者需要在向Bob的银行网站进行的任何传输HTTP请求中包括Bob的cookie。但是，由于攻击者无法读取Bob的cookie，因此攻击者不能仅创建HTTP请求并将其发送到银行网站。攻击者需要使用HTML <code>&lt;img&gt;</code>标记创建一个GET请求，其中包含Bob的cookie。 <code>&lt;img&gt;</code>标记在网页上呈现图像，它包含<code>src</code>属性，该属性指示浏览器在何处获取图像文件。当浏览器渲染<code>&lt;img&gt;</code>标记时，它将向标记中的<code>src</code>属性发出HTTP GET请求，并在该请求中包含所有现有的cookie。因此，假设恶意网站使用如下网址将$ 500从Bob转移到Joe：</p><p><code>https://www.bank.com/transfer?from=bob&amp;to=joe&amp;amount=500</code></p><p>那么，恶意的<code>&lt;img&gt;</code>标签将使用此URL作为其<code>src</code>值：</p><p><code>&lt;img src =“ https://www.bank.com/transfer?from=bob&amp;to=joe&amp;amount=500”&gt;</code></p><p>结果，Bob访问攻击者拥有的网站时，它在HTTP响应中包含<code>&lt;img&gt;</code>标记，然后浏览器向银行发出HTTP GET请求。浏览器发送Bob的身份验证Cookie，以获取其认为应该是图像的图像。但实际上，银行收到了请求，处理了标签的<code>src</code>属性中的URL，并创建了转帐请求。</p><p>为避免此漏洞，开发人员切勿使用HTTP GET请求执行任何后端数据修改请求，例如转账。但是任何只读请求都应该是安全的。许多用于构建网站的常用网络框架（例如Ruby on Rails，Django等）都希望开发人员遵循此原则，因此它们会自动将CSRF保护添加到POST请求中，而不是GET请求中。</p><h2 id="CSRF与POST请求"><a href="#CSRF与POST请求" class="headerlink" title="CSRF与POST请求"></a>CSRF与POST请求</h2><p>如果银行通过POST请求执行转帐，则您需要使用其他方法来创建CSRF攻击。攻击者无法使用<code>&lt;img&gt;</code>标记，因为<code>&lt;img&gt;</code>标记无法调用POST请求。攻击者的策略将取决于POST请求的内容。</p><p>最简单的情况是带有<code>content-type</code> 为<code>application / x-www-form-urlencoded</code>或<code>text / plain</code>的POST请求。<code>content-type</code>是浏览器在发送HTTP请求时可能包含的头。头告诉接收者HTTP请求主体的编码方式。这是一个text/plain类型请求的示例：</p><pre class="line-numbers language-none"><code class="language-none">POST / HTTP/1.1  Host: www.google.ca  User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  Content-Length: 5➊ Content-Type: text/plain;charset=UTF-8  DNT: 1  Connection: close  hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>content-type</code>➊被标记，并且其类型与请求的字符编码一起列出。<code>content-type</code>很重要，因为浏览器对待类型的方式有所不同。</p><p>在这个例子，恶意网站可能会创建隐藏的HTML表单，并在目标不知情的情况下将其提交给易受攻击的网站。该表单可以向URL提交POST或GET请求，甚至可以提交参数值。这是网站中一些有害代码的示例，恶意链接会将Bob定向到这些有害代码：</p><pre class="line-numbers language-none"><code class="language-none">➊ &lt;iframe style="display:none" name="csrf-frame"&gt;&lt;/iframe&gt; ➋ &lt;form method='POST' action='http://bank.com/transfer' target="csrf-frame"   id="csrf-form"&gt;  ➌ &lt;input type='hidden' name='from' value='Bob'&gt;    &lt;input type='hidden' name='to' value='Joe'&gt;    &lt;input type='hidden' name='amount' value='500'&gt;    &lt;input type='submit' value='submit'&gt;   &lt;/form&gt; ➍ &lt;script&gt;document.getElementById("csrf-form").submit()&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它使用表单向Bob的银行发出HTTP POST请求（用<code>&lt;form&gt;</code>标记中的action属性）。由于攻击者不希望Bob看到表单，因此每个<code>&lt;input&gt;</code>元素都被赋予了“hidden”类型，这使它们在Bob看到的网页上不可见。最后一步，攻击者在<code>&lt;script&gt;</code>标记内包含一些JavaScript，以在页面加载时自动提交表单➍。 JavaScript通过在HTML文档上调用<code>getElementByID（）</code>方法来实现此目的，我们在第二行set中将表单的<code>ID（“ csrf-form”）</code>设置为参数。与GET请求一样，一旦提交表单，浏览器就会发出HTTP POST请求，以将Bob的cookie发送到银行网站，该银行网站会调用转帐。由于POST请求将HTTP响应发送回浏览器，因此攻击者使用<code>display：none</code>属性➊将响应隐藏在<code>iFrame</code>中。结果，Bob看不到它，也没有意识到发生了什么。</p><p>有些网站可能希望POST请求使用content-type 为<code>application / json</code>。<code>application/ json</code>类型的请求可能带有CSRF token。该token是与HTTP请求一起提交的值，因此合法网站可以验证该请求是否源于自身而不是来自另一个恶意网站。有时POST请求的HTTP主体中包含token，但在其他时候，POST请求具有一个自定义头，其名称类似于<code>X-CSRF-TOKEN</code>。当浏览器向站点发送一个<code>application / json</code> POST请求时，它将在POST请求之前发送一个OPTIONS 请求。然后，该网站将返回对OPTIONS调用的响应，指示其接受的HTTP请求类型以及受信任的来源。这称为预检OPTIONS调用。浏览器读取此响应，然后发出适当的HTTP请求，在我们的银行示例中，该请求将是用于转账的POST请求。</p><p>如果实施正确，则预检OPTIONS调用可防止某些CSRF漏洞：服务器不会将恶意站点列为受信任的站点，并且浏览器将仅允许特定网站（白名单）读取HTTP OPTIONS响应。结果，由于恶意网站无法读取OPTIONS响应，因此浏览器将不会发送恶意POST请求。</p><p>定义网站何时以及如何读取彼此的响应的一组规则称为跨域资源共享（CORS）。 CORS限制从提供文件或正在测试的站点允许的域之外的域进行资源访问，包括JSON响应访问。换句话说，当开发人员使用CORS保护网站时，除非被测试的网站允许，否则您无法提交应用application/ json请求来调用被测试的应用程序，读取响应并进行另一个调用。在某些情况下，您可以通过<code>content-type</code>更改为<code>application / x-www-form-urlencoded，multipart / form-data or text / plain</code>来绕过这些保护。在发出POST请求时，浏览器不会针对这三种内容类型中的任何一种发送预检OPTIONS调用，因此CSRF请求可能有效。如果不是，请查看服务器HTTP响应中的<code>Access-Control-Allow-Origin</code>，以再次检查服务器是否不信任任意来源。如果从任意来源发送请求时该响应标头发生变化，则该站点可能会有更大的问题，因为该站点允许任何来源读取其服务器的响应。这允许存在CSRF漏洞，但也可能允许恶意攻击者读取服务器的HTTP响应中返回的所有敏感数据。</p><h2 id="防御CSRF攻击"><a href="#防御CSRF攻击" class="headerlink" title="防御CSRF攻击"></a>防御CSRF攻击</h2><p>您可以通过多种方式抵御CSRF漏洞。抵御CSRF攻击的最流行的保护形式之一是CSRF 令牌（token）。提交有可能更改数据的请求（即POST请求）时，受保护的站点需要CSRF令牌。在这种情况下，Web应用程序（例如Bob的银行）将生成一个由两部分组成的令牌：Bob会收到一个令牌，而应用程序会保留一个令牌。当Bob尝试提出转帐请求时，他将必须提交自己的令牌，然后银行将使用令牌这一边对其进行验证。这些令牌的设计使其无法猜测，并且只能由分配给它们的特定用户（例如Bob）访问。此外，它们的名称并不总是很明显，但是名称的一些潜在示例包括<code>X-CSRF-TOKEN</code>，<code>lia-token</code>，<code>rt</code>或<code>form-id</code>。令牌可以包含在HTTP请求头中，HTTP POST主体中或作为隐藏字段，如以下示例所示：</p> <pre class="line-numbers language-none"><code class="language-none">&lt;form method='POST' action='http://bank.com/transfer'&gt;&lt;input type='text' name='from' value='Bob'&gt; &lt;input type='text' name='to' value='Joe'&gt; &lt;input type='text' name='amount' value='500'&gt;&lt;input type='hidden' name='csrf' value='lHt7DDDyUNKoHCC66BsPB8aN4p24hxNu6ZuJA+8l+YA='&gt; &lt;input type='submit' value='submit'&gt;&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在此示例中，网站可以从Cookie，网站上的嵌入式脚本或从网站传递的内容的一部分中获取CSRF令牌。无论采用哪种方法，只有目标服务器的网络浏览器才知道并能够读取该值。由于攻击者无法提交令牌，因此他们将无法成功提交POST请求，也无法进行CSRF攻击。但是，仅网站使用CSRF令牌并不意味着它在搜索要利用的漏洞时是死路一条。可以尝试删除令牌，更改其值等。</p><p>网站保护自己的另一种方式是使用CORS。但是，这并不是万无一失的，因为它依赖于浏览器的安全性并确保正确的CORS配置来确定第三方网站何时可以访问响应。由于服务器端配置错误，攻击者有时可以通过将<code>content-type</code>从<code>application / json</code>更改为<code>application / x-www-form-urlencoded</code>来绕过CORS，或者通过使用GET请求而不是POST请求来绕过CORS。顺利绕过的原因是，当内容类型为<code>application / json</code>时，浏览器将自动发送OPTIONS HTTP请求，但如果是GET请求或内容类型为<code>application / x-www-form</code>，则不会自动发送OPTIONS HTTP请求。</p><p>最后，还有另外两种不太常见的CSRF缓解策略。首先，站点可以检查与HTTP请求一起提交的<code>Origin</code>或<code>Referer</code> header的值，并确保它包含预期值。例如，在某些情况下，Twitter将检查<code>Origin</code>，如果不包含<code>Origin</code>，则检查<code>Referer</code>。之所以可行，是因为浏览器控制这些头，并且攻击者无法远程设置或更改它们（显然，这排除了利用浏览器或浏览器插件中的漏洞可能允许攻击者控制header）。其次，浏览器现在开始实现对名为<code>samesite</code>的新cookie属性的支持。可以将此属性设置为<code>strict</code>或<code>lax</code>。设置为“strict”后，浏览器将不会使用任何不是来自网站的HTTP请求发送Cookie。这甚至包括简单的HTTP GET请求。例如，如果您登录到Amazon并且使用了<code>strict</code>的<code>samesite</code> cookie，那么如果您跟踪来自另一个站点的链接，浏览器将不会提交您的cookie。此外，在您访问另一个Amazon网页并提交cookie之前，Amazon不会将您识别为已登录。相反，将<code>samesite</code>属性设置为lax则指示浏览器发送带有初始GET请求的cookie。这支持GET请求永远不要更改服务器端数据的设计原则。在这种情况下，如果您登录到Amazon并且使用了的<code>lax</code>samesite cookie，则浏览器将提交您的cookie，并且如果您已从另一个站点重定向到该站点，Amazon将识别您已登录。</p><h2 id="漏洞实例"><a href="#漏洞实例" class="headerlink" title="漏洞实例"></a>漏洞实例</h2><h3 id="Shopify-Twitter断开关联"><a href="#Shopify-Twitter断开关联" class="headerlink" title="Shopify Twitter断开关联"></a>Shopify Twitter断开关联</h3><p>难度：低</p><p>网址：<code>https：//twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</code></p><p>资料来源：<a href="https://www.hackerone.com/reports/111216/">https://www.hackerone.com/reports/111216/</a></p><p>报告日期：2016年1月17日</p><p>赏金支付：$ 500</p><p>当您寻找潜在的CSRF漏洞时，请注意用于修改服务器端数据的GET请求。例如，某黑客在Shopify功能中发现了一个漏洞，该漏洞将Twitter集成到网站中，从而使店主可以发布有关其产品的推文。该功能还允许用户从关联的商店断开Twitter帐户关联。断开Twitter帐户的URL为：</p><p><code>https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</code></p><p>事实证明，访问此URL将发送GET请求以断开帐户，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">GET /auth/twitter/disconnect HTTP/1.1Host: twitter-commerce.shopifyapps.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:43.0) Gecko/20100101 Firefox/43.0Accept: text/html, application/xhtml+xml, application/xmlAccept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: https://twitter-commerce.shopifyapps.com/accountCookie: _twitter-commerce_session=REDACTEDConnection: keep-alive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 此外，当链接最初实现时，Shopify并没有验证发送给它的GET请求的合法性，从而使URL容易受到CSRF的攻击。</p><p>提交报告的黑客提供了以下概念验证HTML文档：</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt; &lt;body&gt;  ➊ &lt;img src="https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect"&gt;  &lt;/body&gt; &lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此HTML文档将使浏览器通过<code>&lt;img&gt;</code>标记的<code>src</code>属性将HTTP GET请求发送到<code>https://twitter-commerce.shopifyapps.com</code>。如果拥有连接到Shopify的Twitter帐户的人访问带有此<code>&lt;img&gt;</code>标记的网页，则其Twitter帐户将与Shopify断开关联。</p><p><strong>重点</strong></p><p>密切注意在服务器上执行某些操作的HTTP请求，例如通过GET请求断开Twitter帐户。如前所述，GET请求永远不要修改服务器上的任何数据。在这种情况下，您可以通过使用代理服务器（例如Burp或OWASP的ZAP）来监视发送到Shopify的HTTP请求，从而发现该漏洞。</p><h3 id="更改Instacart用户的区域"><a href="#更改Instacart用户的区域" class="headerlink" title="更改Instacart用户的区域"></a>更改Instacart用户的区域</h3><p>难度：低</p><p>网址：<code>https：//admin.instacart.com/api/v2/zones/</code></p><p>资料来源：<a href="https://hackerone.com/reports/157993/">https://hackerone.com/reports/157993/</a></p><p>报告日期：2015年8月9日</p><p>赏金支付：$ 100</p><p>在查看攻击面时，请记住考虑网站的API endpoint及其网页。 Instacart是一个杂货店交付应用程序，它允许其交付者定义他们工作的区域。该站点通过向Instacart 的admin子域发送POST请求来更新这些区域。黑客发现该子域上的区域容易受到CSRF的攻击。您可以使用以下代码修改目标区域：</p> <pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;body&gt;  ➊ &lt;form action="https://admin.instacart.com/api/v2/zones" method="POST"&gt;   ➋ &lt;input type="hidden" name="zip" value="10001" /&gt;  ➌ &lt;input type="hidden" name="override" value="true" /&gt;  ➍ &lt;input type="submit" value="Submit request" /&gt;  &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此示例中，黑客创建了一个HTML表单，以将HTTP POST请求发送到<code>/ api / v2 / zones</code>➊。它包括两个隐藏的输入：一个将用户的新区域设置为邮政编码10001➋，另一个将API的override参数设置为true➌，以便将用户的当前zip值替换为黑客提交的值。另外，与Shopify示例不同，黑客使用了一个提交按钮来发出POST请求，而Shopify示例使用了自动提交JavaScript函数。</p><p>尽管此示例仍然成功，但黑客可以通过使用前面介绍的技术来改善漏洞利用，例如使用隐藏的iFrame代表目标用户自动提交请求。这将向Instacart漏洞赏金分类程序演示攻击者如何以较少的目标操作来使用此漏洞；与未完全控制相比，完全由攻击者控制的漏洞更有可能获得奖金。</p><p><strong>重点</strong></p><p>当您寻找漏洞利用时，请扩大攻击范围，并不仅仅是网站页面，而是要包含其API endpoint，这些endpoint很可能带来漏洞。有时，开发人员会忘记黑客可以发现和利用API endpoint，因为它们不像网页那样容易获得。移动应用程序经常向API endpoint发出HTTP请求，您可以像访问网站一样使用Burp或ZAP进行监视。</p><h3 id="Badoo完全帐户接管"><a href="#Badoo完全帐户接管" class="headerlink" title="Badoo完全帐户接管"></a>Badoo完全帐户接管</h3><p>难度：中等</p><p>网址：<code>https：//www.badoo.com/</code></p><p>资料来源：<a href="https://hackerone.com/reports/127703/">https://hackerone.com/reports/127703/</a></p><p>报告日期：2016年4月1日</p><p>赏金支付：852美元</p><p>尽管开发人员经常使用CSRF令牌来防御CSRF漏洞，但在某些情况下，攻击者可以窃取令牌，如您在此漏洞中所看到的。如果您浏览社交网站<code>https://www.badoo.com/</code>，将会看到它使用CSRF令牌。更具体地说，它使用每个用户唯一的URL参数<code>rt</code>。当Badoo的Bug赏金计划在HackerOne上发布时，我找不到利用它的方法。但是，黑客Mahmoud Jamal确实做到了。</p><p>Jamal认识到<code>rt</code>参数及其意义。他还注意到几乎所有JSON响应都返回了该参数。不幸的是，这无济于事，因为CORS可以保护Badoo免受攻击者读取这些响应的攻击，因为它们被编码为<code>application / json</code>内容类型。但是Jamal坚持挖掘。</p><p>Jamal最终找到了JavaScript文件<code>https://eu1.badoo.com/worker-scope/chrome-service-worker.js</code>，该文件包含一个名为<code>url_stats</code>的变量，并设置为以下值：</p><p><code>var url_stats ='https://eu1.badoo.com/chrome-push-stats?ws=1&amp;rt= &lt;➊rt_param_value&gt;';</code></p><p>当用户的浏览器访问JavaScript文件➊时，<code>url_stats</code>变量存放一个URL，该URL包含用户的唯一<code>rt</code>值作为参数。为了获得用户的<code>rt</code>值，攻击者只需要受害者访问包含JavaScript文件的恶意网页。 CORS不会阻止此操作，因为它允许浏览器从外部源读取和嵌入远程JavaScript文件。然后，攻击者可以使用<code>rt</code>值将任何社交媒体帐户与用户的Badoo帐户相关联。结果，攻击者可以调用HTTP POST请求来修改目标帐户。这是Jamal用于完成此攻击的HTML：</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;   &lt;title&gt;Badoo account take over&lt;/title&gt;  ➊ &lt;script src=https://eu1.badoo.com/worker-scope/chrome-service-worker.js?ws=1&gt;&lt;/script&gt;  &lt;/head&gt; &lt;body&gt;   &lt;script&gt;   ➋ function getCSRFcode(str) {     return str.split('=')[2];    }   ➌ window.onload = function(){   ➍ var csrf_code = getCSRFcode(url_stats);    ➎ csrf_url = 'https://eu1.badoo.com/google/verify.phtml?code=4/nprfspM3y  fn2SFUBear08KQaXo609JkArgoju1gZ6Pc&amp;authuser=3&amp;session_state=7cb85df679     219ce71044666c7be3e037ff54b560..a810&amp;prompt=none&amp;rt='+ csrf_code;    ➏ window.location = csrf_url;    };   &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当目标加载该页面时，该页面将通过在<code>&lt;script&gt;</code>标记➊中将其作为<code>src</code>属性引用来加载Badoo的 JavaScript。加载脚本后，网页将调用JavaScript函数<code>window.onload</code>，它定义了一个匿名JavaScript函数➌。网页加载时，浏览器调用<code>onload</code>事件处理程序；因为Jamal定义的函数在<code>window.onload</code>处理程序中，所以在加载页面时就会调用他的函数。</p><p>接下来，Jamal创建了一个<code>csrf_code</code>变量➍，并为其分配了在➋处定义的名为<code>getCSRFcode</code>的函数的返回值。 <code>getCSRFcode</code>函数在每个’=’字符处将字符串分割成字符串数组。然后，它返回数组的第三个成员的值。当函数从Badoo易受攻击的JavaScript文件中解析变量<code>url_stats</code>时，它将字符串拆分为以下数组值：</p><p><code>https://eu1.badoo.com/chrome-push-stats?ws,1&amp;rt,&lt;rt_param_value&gt;</code></p><p>然后，该函数返回数组的第三个成员（即<code>rt</code>值），并将其分配给<code>csrf_code</code>。</p><p>拥有CSRF令牌后，Jamal创建了<code>csrf_url</code>变量，该变量存储了指向Badoo的<code>/google/verify.phtml</code>网页的URL。该网页将自己的Google帐户链接到目标的Badoo帐户➎。该页面需要一些参数，这些参数被硬编码到URL字符串中。我不会在这里详细介绍它们，因为它们特定于Badoo。但是，请注意最后的<code>rt</code>参数，该参数没有硬编码的值。而是将<code>csrf_code</code>连接到URL字符串的末尾，以便将其作为<code>rt</code>参数的值传递。然后，Jamal通过调用<code>window.location</code> 发出HTTP请求，并将其分配给<code>csrf_url</code>，<code>csrf_url</code>将访问用户的浏览器重定向到➎处的URL。这会致使对Badoo的GET请求，该请求会验证<code>rt</code>参数并处理该请求，以将目标的Badoo帐户链接到Jamal的Google帐户，从而完成帐户的接管。</p><p><strong>重点</strong></p><p>哪里有烟，哪里就有火。 Jamal注意到<code>rt</code>参数在不同的位置返回，尤其是在JSON响应中返回。因此，他正确地猜测到rt可能会出现在攻击者可以访问和利用它的某个地方，在本例中为javascript文件。如果您觉得网站可能容易受到攻击，请继续进行挖掘。在这种情况下，我认为CSRF令牌只有五位数字并包含在URL中是很奇怪的。通常，令牌要长得多，使令牌更难猜测，并且包含在HTTP POST请求正文中，而不是URL中。使用代理，并检查访问站点或应用程序时正在调用的所有资源。 Burp允许您搜索所有代理历史记录以查找特定的值，这将显示此处JavaScript文件中包含的<code>rt</code>值。您可能会发现包含敏感数据（例如CSRF令牌）的信息泄漏。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查找CSRF漏洞可能需要一些独创性和坚韧性来测试网站上的所有功能。通常，如果站点正在执行POST请求，则诸如Ruby on Rails之类的应用程序框架将越来越多地保护Web表单。但是，对于GET请求而言并非如此。因此，请务必注意任何更改服务器端用户数据的GET HTTP调用（例如断开Twitter帐户的连接）。另外，尽管我没有提供示例，但是如果您发现站点正在发送带有POST请求的CSRF令牌，则可以尝试更改CSRF令牌值或将其完全删除以确保服务器验证其存在。</p>]]></content>
      
      
      <categories>
          
          <category> Web Hacking 101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part3 HTTP参数污染</title>
      <link href="2020/10/14/part3-http-can-shu-wu-ran/"/>
      <url>2020/10/14/part3-http-can-shu-wu-ran/</url>
      
        <content type="html"><![CDATA[<h1 id="Part3-HTTP参数污染"><a href="#Part3-HTTP参数污染" class="headerlink" title="Part3 HTTP参数污染"></a><center>Part3 HTTP参数污染</center></h1><p> <font color="#A52A2A" size="4"><em>本文部分翻译自Peter Yaworski的《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>HTTP参数污染（HPP）是操纵网站如何处理其在HTTP请求期间收到的参数的过程。当攻击者向请求中注入额外的参数并且目标网站信任它们时，就会发生此漏洞，从而导致意外行为。 HPP漏洞可能发生在服务器端或客户端。在客户端（通常是您的浏览器）上，您可以看到测试的效果。在许多情况下，HPP漏洞取决于服务器端代码如何使用作为参数传递的值，这些值由攻击者控制。因此，与其他类型的错误相比，发现这些漏洞可能需要更多的试验。</p><h2 id="服务器端HPP"><a href="#服务器端HPP" class="headerlink" title="服务器端HPP"></a>服务器端HPP</h2><p>在服务器端HPP中，您向服务器发送了意外的信息，以使服务器端的代码返回意外的结果。如part1所述，当您向网站发出请求时，站点的服务器将处理该请求并返回响应。在某些情况下，服务器不仅会返回网页，还会根据收到的信息运行一些代码。该代码仅在服务器上运行，因此基本上对您不可见：您可以看到发送的信息和返回的结果，但是中间的代码不可见。因此，您只能推断正在发生的事情。由于看不到服务器代码的功能，因此服务器端HPP取决于您确定潜在的易受攻击参数并进行试验。</p><p>让我们看一个例子：如果您的银行通过接受其服务器上处理的URL参数通过其网站启动转帐，则服务器端HPP可能会发生。想象一下，您可以通过在三个URL参数from，to和amount中输入值来转移资金。每个参数按顺序指定要从其转帐的帐号，要转帐的帐号和转帐金额。具有以下参数的URL会将$ 5,000从帐号12345转移到帐号67890，如下所示：</p><p><code>https://www.bank.com/transfer?from=12345&amp;to=67890&amp;amount=5000</code></p><p>银行可能会假设它将仅从参数中接收一个。但是，如果您提交两个，则会发生以下情况：</p><p><code>https://www.bank.com/transfer?from=12345&amp;to=67890&amp;amount=5000&amp;from=ABCDEF</code></p><p>该URL的初始结构与第一个示例相同，但附加了一个from参数，该参数指定另一个发送帐户ABCDEF。在这种情况下，攻击者将发送额外的参数，以希望应用程序使用第一个from参数来验证转移，但使用第二个参数来取款。因此，如果银行信任它收到的最后一个参数，则攻击者可能能够从他们不拥有的帐户执行转移。服务器端代码将使用第二个参数从帐户ABCDEF汇款到67890，而不是从帐户12345到帐户12345转移$ 5,000。</p><p>当服务器接收到多个具有相同名称的参数时，它可以通过多种方式进行响应。例如，PHP和Apache使用最后一次出现，Apache Tomcat使用第一次出现，ASP和IIS使用所有出现，依此类推。两位研究人员Luca Carettoni和Stefano di Paolo在AppSec EU 09大会上详细介绍了服务器技术之间的许多差异：此信息现在可在OWASP网站上找到，网址为<code>https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf</code>（请参见幻灯片9）。因此，没有一个单一的保证流程来处理具有相同名称的多个参数提交，并且发现HPP漏洞需要做一些试验来确认您正在测试的网站的工作方式。</p><p>银行示例使用了显而易见的参数。但是有时HPP漏洞是由于无法直接看到的代码隐藏的服务器端行为而发生的。例如，假设您的银行决定修改其处理转帐的方式，并更改其后端代码以在URL中不包含from参数。这次，银行将使用两个参数，一个参数用于转帐的目标账号，另一个参数用于转帐金额。要转移的帐户将由服务器设置，您看不到该帐户。一个示例链接如下所示：</p><p><code>https://www.bank.com/transfer?to=67890&amp;amount=5000</code></p><p>通常，服务器端代码对我们来说是一个谜，但是对于本示例而言，我们知道银行的（非常糟糕和冗余的）服务器端Ruby代码如下所示：</p><pre class="line-numbers language-none"><code class="language-none">user.account = 12345 def prepare_transfer(➊params)  ➋ params &lt;&lt; user.account  ➌ transfer_money(params) #params[2] =user.account (12345)end def transfer_money(params)  ➍ to = params[0]  ➎ amount = params[1]  ➏ from = params[2]   transfer(to,amount,from) end <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此代码创建两个函数prepare_transfer和transfer_money。 prepare_transfer函数采用名为params 的数组，该数组包含URL中的to和amount参数。该数组将为[67890,5000]，其中数组值夹在方括号之间，并且每个值都用逗号分隔。函数first的第一行将代码前面定义的用户帐户信息添加到数组的末尾。我们以params数组[67890,5000,12345]，然后将params传递给transfer_money➌。请注意，与参数不同，数组没有与它们的值关联的名称，因此代码取决于始终按顺序包含每个值的数组：要转移到的帐户是第一个，要转移的金额是下一个，要转移的帐户from跟紧其他两个值后面。在transfer_money中，随着函数将每个数组值分配给变量，值的顺序变得很明显。由于数组位置从0开始编号，因此params [0]访问数组中第一个位置的值（在这种情况下为67890），并将其分配给变量。然后将接下来的值分配给变量amount和from。然后，将变量名传递到此代码段中未显示的传递函数，该函数接受值并进行转账。</p><p>理想情况下，URL参数将始终按照代码期望的方式进行格式化。但是，攻击者可以通过将from值传递给params来更改此逻辑的结果，例如以下URL：</p><p><code>https://www.bank.com/transfer?to=67890&amp;amount=5000&amp;from=ABCDEF</code></p><p>在这种情况下，from参数也包含在传递给prepare_transfer函数的params数组中；因此，数组的值将为[67890,5000，ABCDEF]，将用户帐户添加为in将得到[67890,5000，ABCDEF，12345]。结果，在prepare_transfer中调用的transfer_money函数中，from变量将采用第三个参数，但它不是期望的user.account值（12345），而是攻击者传入的账号ABCDEF➍。</p><h2 id="客户端HPP"><a href="#客户端HPP" class="headerlink" title="客户端HPP"></a>客户端HPP</h2><p>客户端HPP漏洞使攻击者可以向URL中注入额外的参数，从而在影响用户端（客户端是指通常通过浏览器而非站点服务器） 。</p><p>Luca Carettoni和Stefano di Paola在其演示文稿中使用根据理论构造的URL <code>http：//host/page.php？par = 123％26action = edit</code>和以下服务器端代码，演示了此类操作的示例：</p><pre class="line-numbers language-none"><code class="language-none">➊ &lt;? $val=htmlspecialchars($_GET['par'],ENT_QUOTES); ?&gt; ➋ &lt;a href="/page.php?action=view&amp;par='.&lt;?=$val?&gt;.'"&gt;View Me!&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这段代码根据par的值（用户输入的参数）生成一个新的URL。 在此示例中，攻击者将值123％26action = edit作为par的值传递来生成附加的参数。 接下来，par被传递给函数htmlspecialchars➊。htmlspecialchars函数将特殊字符（如%26）转换为它们的HTML编码值，即将%26转换为&amp;，其中该字符可能具有特殊含义。转换后的值存储在$val中。然后通过将$val附加到位于➋的href值生成新链接。所以生成的链接会变成<code>&lt;a href=“/page.php？action=view&amp;par=123&amp;action=edit“&gt;</code>。因此，攻击者成功将附加action=edit添加到href，这可能会导致漏洞，具体取决于应用程序如何处理action参数。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><h3 id="HackerOne社交分享按钮"><a href="#HackerOne社交分享按钮" class="headerlink" title="HackerOne社交分享按钮"></a>HackerOne社交分享按钮</h3><p>难度：低</p><p>网址：<code>https：//hackerone.com/blog/introducing-signal-and-impact/</code></p><p>资料来源：<a href="https://hackerone.com/reports/105953/">https://hackerone.com/reports/105953/</a></p><p>报告日期：2015年12月18日</p><p>赏金支付：$ 500</p><p>查找HPP漏洞的一种方法是查找可能与其他服务联系的链接。 你可以在流行的社交媒体网站（例如Twitter，Facebook等）上通过包含链接以分享HackerOne的博客。在HackerOne的博客页面上单击“分享”，HackerOne将生成链接供用户在社交媒体上发布，发布的内容包括原始博客文章的URL。</p><p>该漏洞使您可以在HackerOne博客文章的URL上添加参数。添加的URL参数将反映在共享的社交媒体链接中，以便生成的社交媒体内容将链接到除预期的HackerOne博客URL之外的其他位置。</p><p>漏洞报告中使用的示例包含访问URL<code> https://hackerone.com/blog/introducing-signal</code>，然后在其末尾添加<code>＆u = https：//vk.com/durov</code>。在博客页面上，当HackerOne显示一个要在Facebook上共享的链接时，该链接将变为以下内容：</p><p><code>https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal？＆u = https：//vk.com/durov</code></p><p>如果HackerOne访问者在尝试共享内容时单击了此恶意链接，则最后一个u参数将优先于第一个u参数。随后，Facebook帖子将使用最后的u参数。然后，单击链接的Facebook用户将被定向到<code>https://vk.com/durov</code>而不是HackerOne。</p><p>此外，在发布到Twitter时，HackerOne会包含用于推广该帖子的默认tweet文本。攻击者还可以通过在URL中包含＆text =来操纵此文本，如下所示：</p><p><code>https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov＆text = another_site：https：//vk.com/durov</code></p><p>当用户单击此链接时，他们将看到一个包含文本 <code>another_site：https://vk.com/durov</code>的推文弹出窗口，而不是宣传HackerOne博客的文本。</p><p><strong>重点</strong></p><p>当网站与另一个Web服务（例如社交媒体网站）关联并依靠当前URL生成要发布的内容时，请寻找漏洞的机会。在这种情况下，提交的内容可能未经适当的安全检查就被传递，这可能导致参数污染漏洞。</p><h3 id="Twitter取消订阅通知"><a href="#Twitter取消订阅通知" class="headerlink" title="Twitter取消订阅通知"></a>Twitter取消订阅通知</h3><p>难度：低</p><p>网址：<code>https：//www.twitter.com/</code></p><p>资料来源：<a href="https://blog.mert.ninja/twitter-hpp-vulnerability/">https://blog.mert.ninja/twitter-hpp-vulnerability/</a></p><p>报告日期：2015年8月23日</p><p>赏金支付：700美元</p><p>在某些情况下，成功发现HPP漏洞需要坚韧不拔的精神。在2015年8月，黑客Mert Tasci在取消订阅接收Twitter通知时注意到了一个有趣的URL：</p><p><code>https://twitter.com/i/u?iid=F6542&amp;uid=1134885524&amp;nid=22+26&amp;sig=647192e86e28fb6691db2502c5ef6cf3xxx</code></p><p>注意参数UID。该UID恰好是当前登录的Twitter帐户的用户ID。在注意到UID之后，Tasci做了大多数黑客会做的事情——他试图将UID更改为另一个用户的UID，但是什么也没有发生。 Twitter只是返回了一个错误。</p><p>但是Tasci并没有气馁，继续研究，尝试添加第二个UID参数：</p><p><code>https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26&amp;sig=647192e86e28fb6691db2502c5ef6cf3xxx</code></p><p>这次成功了！他设法取消了其他用户的电子邮件通知订阅。 Twitter容易受到HPP退订用户的攻击。此漏洞值得注意的原因与SIG参数有关。事实证明，Twitter使用UID值生成SIG值。当用户单击取消订阅的URL时，Twitter将通过检查SIG和UID值来验证URL是否未被篡改。因此，在Tasci的开始的测试中，更改UID以取消订阅另一个用户失败，因为签名不再符合Twitter的期望。但是，通过添加第二个UID，Tasci成功地使Twitter使用第一个UID参数验证签名，但使用第二个UID参数执行取消订阅操作。</p><p><strong>重点</strong></p><p>Tasci的努力证明了坚持和知识的重要性。如果他在将UID更改为另一个用户并失败后就放弃了该漏洞，或者根本不知道HPP型漏洞，那么他将不会获得700美元的赏金。</p><p>另外，还要注意HTTP请求中包含的具有自动递增的整数（例如UID）的参数：许多漏洞涉及操纵此类参数值，以使Web应用程序以意外方式运行。</p><h3 id="Twitter-Web-Intents"><a href="#Twitter-Web-Intents" class="headerlink" title="Twitter Web Intents"></a>Twitter Web Intents</h3><p>难度：低</p><p>网址：<code>https：//twitter.com/</code></p><p>资料来源：<a href="https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/">https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/</a></p><p>报告日期：2015年11月</p><p>赏金支付：未公开</p><p>在某些情况下，HPP漏洞可能表示存在其他问题，并且可能导致发现其他错误。这就是Twitter Web Intents功能中发生的事情。该功能提供弹出流，用于在非Twitter网站的上下文中处理Twitter用户的推文，回复，转发推文，点赞和关注。 Twitter Web Intents使用户可以与Twitter内容进行交互，而无需离开页面或只为交互进行授权新应用程序。图3-1显示了这些弹出窗口之一的示例。</p><p>图3-1：Twitter Web Intents功能的早期版本，该功能使用户无需离开页面即可与Twitter内容进行交互。在此示例中，用户可以喜欢杰克的推文。</p><p>通过测试此功能，黑客埃里克·拉法洛夫（Eric Rafaloff）发现，四种Intent类型（关注用户，点赞推文，转发和发推）都容易受到HPP的攻击。 Twitter将通过具有URL参数的GET请求创建每个Intent，如下所示：</p><p><code>https://twitter.com/intent/intentType?parameter_name=parameterValue</code></p><p>该URL将包括intentType和一个或多个参数名称/值对——例如，Twitter用户名和Tweet ID。 Twitter将使用这些参数来创建pop-up Intent，以显示要关注的用户或点赞的内容。 Rafaloff在创建以下带有两个screen_name参数的URL时发现了一个问题：</p><p><code>https://twitter.com/intent/follow?screen_name=twitter&amp;screen_name=ericrtest3</code></p><p>Twitter将通过在生成“关注”按钮时将使用第二个screen_name值（ericrtest3）而不是第一个值（twitter）。因此，试图关注Twitter官方帐户的用户会变成关注Rafaloff的测试帐户“ericrtest3”。访问Rafaloff创建的URL时，Twitter的后端代码使用两个screen_name参数生成以下HTML表单：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">➊&lt;form class =“ follow” id =“ follow_btn_form” action =“/intent/follow?screen_name = ericrtest3“ method =” post“&gt;   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">hidden”</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">authenticity_token”</span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">...”</span><span class="token punctuation">&gt;</span></span> ➋<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">hidden”</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">screen_name”</span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">twitter”</span><span class="token punctuation">&gt;</span></span> ➌<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">hidden”</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">profile_id”</span> <span class="token attr-name">value</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">783214”</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">button”</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span>“</span> <span class="token attr-name">submit”</span><span class="token punctuation">&gt;</span></span>​    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">&gt;</span></span> &lt;/ b&gt; <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>关注&lt;/ strong&gt;   &lt;/ button&gt;  &lt;/ form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Twitter将使用来自第一个screen_name参数的信息，该参数与官方Twitter帐户相关联。</p><p>结果，目标用户将看到他们想要关注的用户的正确个人资料，因为URL的第一个screen_name参数用于在➋和➌处填充代码。但是，单击按钮后，目标将关注ericrtest3而不是twitter，因为form标记中的操作将改为使用传递给原始URL的第二个screen_name参数的值➊。</p><p>同样，在显示“点赞”的Intent时，Rafaloff发现他可以在url中包括screen_name参数，尽管它与点赞该推文没有任何关系。他创建了以下URL：</p><p><code>https://twitter.com/intent/like?tweet_i.d=6616252302978211845&amp;screen_name = ericrtest3</code></p><p>虽然intent仅需要tweet_id参数；但是，Rafaloff将screen_name参数注入到URL的末尾。这样就可以向用户显示正确的用户想要点赞的推文内容，但是，如果用户点了该推文的“关注”按钮，用户将关注“erictest3”而不是该推文的原作者。</p><p><strong>重点</strong></p><p>Twitter Web Intents漏洞类似于先前的UID Twitter漏洞。当站点容易受到HPP之类的漏洞的影响时，它可能表明存在更广泛的系统问题。有时，当您发现此类漏洞时，值得花时间全面探索该平台，看看是否还有其他地方可以利用类似行为。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HPP带来的风险取决于网站后端执行的操作以及使用污染参数的位置。</p><p>发现HPP漏洞需要进行彻底的测试，而对于其他一些漏洞的测试则需要更多的测试，因为我们通常无法访问收到HTTP请求后运行的代码服务器。这意味着我们只能推断站点如何处理传递给它们的参数。 </p><p>通过反复试验，您可能会发现HPP漏洞发生的情况。 通常，社交媒体链接是测试此漏洞类型的一个很好的首选，但切记在测试参数替换（例如类似ID的值）时，请继续挖掘并思考HPP。</p>]]></content>
      
      
      <categories>
          
          <category> Web Hacking 101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part2 开放式重定向</title>
      <link href="2020/10/14/part2-kai-fang-shi-chong-ding-xiang/"/>
      <url>2020/10/14/part2-kai-fang-shi-chong-ding-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Part2-开放式重定向"><a href="#Part2-开放式重定向" class="headerlink" title="Part2 开放式重定向 "></a><center>Part2 开放式重定向 </center></h1><p><font color="#A52A2A" size="4"><em>本文是Peter Yaworski的《Web Hacking 101》的翻译笔记，仅供参考学习，禁止二传。</em></font></p><p>开放重定向利用对给定域名的信任来将目标引诱到恶意网站。网络钓鱼攻击伴随重定向，以欺骗用户，使用户认为他们的信息被发送到受信任的站点时，事实上他们正在将信息提交给恶意站点。</p><p>由于开放式重定向只会重定向用户，因此有时他们被认为影响不大不应受到赏金。OWASP是一个专注于应用程序安全性的社区，它整理了Web应用程序中最关键的安全漏洞列表，并从其2017年十大漏洞列表中删除了开放重定向。</p><p>尽管开放重定向是影响较小的漏洞，但它们对于学习浏览器通常如何处理重定向非常有用。</p><h2 id="开放式重定向的工作方式"><a href="#开放式重定向的工作方式" class="headerlink" title="开放式重定向的工作方式"></a>开放式重定向的工作方式</h2><p>当开发人员不信任攻击者控制的输入以将其重定向到另一个站点时，通常会通过URL参数，HTML <code>&lt;meta&gt;</code>刷新标签或DOM窗口位置属性来进行开放重定向。</p><p>许多网站通过将目标URL作为参数放置在原始URL中，有意地将用户重定向到其他站点。应用程序使用此参数来告诉浏览器将GET请求发送到目标URL。例如，假设Google具有通过访问以下URL将用户重定向到Gmail的功能：</p><pre class="line-numbers language-none"><code class="language-none">https://www.google.com/?redirect_to=https://www.gmail.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，当您访问该URL时，Google会收到GET HTTP请求，并使用redirect_to参数的值确定将浏览器重定向到的位置。这样做之后，Google服务器会返回HTTP响应，并带有状态码，指示浏览器重定向用户。通常，状态代码为302，但在某些情况下，状态代码可能为301、303、307或308。</p><p>这些HTTP响应代码告诉您的浏览器已找到页面；但是，该代码还会通知浏览器对redirect_to参数的值<code>https://www.gmail.com/</code>发出GET请求，该值在HTTP响应的Location头中表示。 Location头指定将GET请求重定向到的位置。</p><p>现在，假设攻击者将原始URL更改为以下内容：</p><p><code>https://www.google.com/?redirect_to=https://www.attacker.com</code></p><p>如果Google未能验证redirect_to参数是否用于发送给合法站点之一，则攻击者可以用其自己的URL替换该参数。结果就是，HTTP响应可能指示您的浏览器向<code>https://www.attacker.com</code>发出GET请求。攻击者将您带到恶意站点之后，他们可以进行其他攻击。</p><p>寻找这些漏洞时，请留意包含某些名称的URL参数，例如url =，redirect =，next =等，它们可能表示用户将被重定向到的URL。另外请记住，重定向参数可能不一定总是被明确命名。参数会因站点而异，甚至在一个站点内也会有所不同。在某些情况下，参数可能仅用单个字符标记，例如r =或u =。</p><p>除了基于参数的攻击之外，HTML<code> &lt;meta&gt;</code>标记和JavaScript可以重定向浏览器。 HTML <code>&lt;meta&gt;</code>标签可以告诉浏览器刷新网页，并对标签的content属性中定义的URL发出GET请求。例如：</p><meta http-equiv="refresh" content="0; url=https://www.google.com/"><p>content属性定义浏览器如何通过两个步骤发出HTTP请求。首先，content属性定义浏览器在对URL发出HTTP请求之前要等待多长时间。在这个例子，为0秒。其次，content属性指定浏览器向其发出GET请求的网站中的URL参数；在这个例子里是<code>https://www.google.com</code>。攻击者可以在能够控制<code>&lt;meta&gt;</code>标记的content属性或通过其他漏洞注入自己的标记的情况下使用此重定向行为。 </p><p>攻击者还可以使用JavaScript通过文档对象模型（DOM）修改Window.location属性来重定向用户。 DOM是用于HTML和XML文档的API，允许开发人员修改网页的结构，样式和内容。由于location属性表示应将请求重定向到的位置，因此浏览器将立即解释此JavaScript并重定向到指定的URL。攻击者可以使用以下任何JavaScript来修改Window.location属性：</p><pre class="line-numbers language-none"><code class="language-none">window.location = https://www.google.com/window.location.href = https://www.google.com window.location.replace(https://www.google.com)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通常，只有在攻击者可以通过跨站点脚本漏洞执行JavaScript或网站故意允许用户定义要重定向的URL的情况下，才设置window.location值的机会才会出现，如稍后将看到的HackerOne插页式重定向漏洞。</p><h2 id="漏洞示例"><a href="#漏洞示例" class="headerlink" title="漏洞示例"></a>漏洞示例</h2><h3 id="Shopify主题安装开放重定向"><a href="#Shopify主题安装开放重定向" class="headerlink" title="Shopify主题安装开放重定向"></a>Shopify主题安装开放重定向</h3><p>难度：低</p><p>网址：<code>https：//apps.shopify.com/services/google/themes/preview/supply--blue？domain_name = &lt;anydomain&gt;</code></p><p>资料来源：<a href="https://www.hackerone.com/reports/101962/">https://www.hackerone.com/reports/101962/</a></p><p>报告日期：2015年11月25日</p><p>赏金支付：$ 500</p><p>第一个开放式重定向示例是在Shopify上找到的，Shopify是一个商务平台，用户可以创建商店来销售商品。 Shopify允许管理员通过更改主题来自定义商店的外观。作为该功能的一部分，Shopify提供了通过将商店所有者重定向到URL来提供主题预览的功能。重定向URL的格式如下：</p><p><code>https://app.shopify.com/services/google/themes/preview/supply--blue?domain_name=attacker.com</code></p><p>URL末尾的domain_name参数重定向到用户的商店域，并将/ admin添加到URL末尾。 Shopify认为domain_name始终是用户的商店，并且未验证其值是否属于Shopify域的一部分。结果，攻击者可以利用该参数将目标重定向到<code>http：// &lt;attacker&gt; .com / admin /</code>，在此恶意攻击者可以进行其他攻击。 </p><p><strong>重点</strong></p><p>并非所有漏洞都很复杂。对于此开放式重定向，只需将domain_name参数更改为外部站点即可将用户从Shopify重定向到其他位置。</p><h3 id="Shopify登录开放重定向"><a href="#Shopify登录开放重定向" class="headerlink" title="Shopify登录开放重定向"></a>Shopify登录开放重定向</h3><p>难度：低</p><p>网址：<code>http：//mystore.myshopify.com/account/login/</code></p><p>资料来源：<a href="https://www.hackerone.com/reports/103772/">https://www.hackerone.com/reports/103772/</a></p><p>报告日期：2015年12月6日</p><p>赏金支付：$ 500</p><p>开放重定向的第二个示例与第一个Shopify示例相似，不同的是，在这个例子，Shopify的参数不是将用户重定向到URL参数指定的域。而是开放式重定向会将参数的值添加到Shopify子域的末尾。通常，此功能将用于将用户重定向到给定商店的特定页面。但是，攻击者仍然可以通过添加字符来更改URL的含义，从而操纵这些URL将浏览器从Shopify的子域重定向到攻击者的网站。</p><p>在此漏洞中，用户登录Shopify后，Shopify使用参数checkout_url重定向。例如，假设某个目标访问了此URL：</p><p><code>http://mystore.myshopify.com/account/login?checkout_url=.attacker.com</code></p><p>它们将被重定向到不是Shopify域的URL<code> http://mystore.myshopify.com.&lt;attacker&gt;.com</code>。</p><p>因为URL以<code>.&lt;attacker&gt; .com</code>结尾，并且DNS查找使用最右边的域标签，所以重定向将转到<code>&lt;attacker&gt; .com</code>域。因此，当提交<code>http://mystore.myshopify.com.&lt;attacker&gt; .com /</code>进行DNS查找时，它将与Shopify不拥有<code>&lt;attacker&gt; .com</code>匹配，而不是Shopify拥有的<code>myshopify.com</code>。尽管攻击者无法任意地将目标发送到任意地方，但他们可以通过在可以操纵的值上添加特殊字符（例如”.”）来将用户发送到另一个域名。</p><p><strong>重点</strong></p><p>如果您只能控制站点使用的最终URL的一部分，则添加特殊的URL字符可能会更改URL的含义并将用户重定向到另一个域。假设您只能控制checkout_url参数值，并且您还注意到该参数与网站后端的硬编码URL（例如商店URL<code> http://mystore.myshopify.com/</code>）组合在一起。尝试添加特殊的URL字符（例如，”.”或”@”），以测试是否可以控制重定向的位置。</p><h3 id="HackerOne插页式重定向"><a href="#HackerOne插页式重定向" class="headerlink" title="HackerOne插页式重定向"></a>HackerOne插页式重定向</h3><p>难度：低</p><p>网址：N / A</p><p>资料来源：<a href="https://www.hackerone.com/reports/111968/">https://www.hackerone.com/reports/111968/</a></p><p>报告日期：2016年1月20日</p><p>赏金支付：$ 500</p><p>一些网站试图通过实施插页式网页来防止打开的重定向漏洞，插页式网页在预期内容之前显示。每当您将用户重定向到URL时，您都可以显示一个插页式网页，并显示一条消息，向用户说明他们正在离开其所在的域。因此，如果重定向页面显示伪造的登录名或试图假装为可信域，则用户将知道他们正在被重定向。这是HackerOne在其网站上跟踪大多数URL时采用的方法。</p><p>尽管您可以使用插页式网页来避免重定向漏洞，但网站彼此交互方式的复杂性可能导致链接受损。 HackerOne将Zendesk（客户服务支持票务系统）用于其<code>https://support.hackerone.com/</code>子域。当您在hackerone.com上使用/ zendesk_session时，浏览器从HackerOne的平台重定向到没有插页页面的HackerOne的Zendesk平台，因为包含hackerone.com域的URL是受信任的链接。但是，任何人都可以创建自定义的Zendesk帐户和将它们传递给/ redirect_to_account？state =参数。然后，自定义的Zendesk帐户可以重定向到非Zendesk或HackerOne拥有的另一个网站。因为Zendesk允许在没有插页式页面的帐户之间进行重定向，所以可以将用户带到不受信任的站点而不会发出警告。作为解决方案，HackerOne将包含zendesk_session的链接识别为外部链接，从而在单击时显示了一个插页式警告页面。</p><p>为了确认此漏洞，黑客Mahmoud Jamal在Zendesk上创建了一个子域为<code>http://compayn.zendesk.com</code>的帐户。然后，他使用Zendesk主题编辑器将以下JavaScript代码添加到了头文件中，该文件允许管理员自定义Zendesk网站的外观：</p><p><code>&lt;script&gt;document.location.href = «http://evil.com»;&lt;/script&gt;</code></p><p>Jamal使用此JavaScript指示浏览器访问<code>http://evil.com</code>。 <code>&lt;script&gt;</code>标记表示HTML中的代码，document指的是Zendesk返回的整个HTML文档，这是网页的信息。Document后的点和名称是其属性。属性包含描述对象或可以操纵以更改对象的信息和值。因此，您可以使用location属性来控制浏览器显示的网页，并使用href子属性（这是location的属性）将浏览器重定向到定义的网站。访问以下链接会将目标重定向到Jamal的Zendesk子域，这使目标的浏览器运行Jamal的脚本并将其重定向到<code>http://evil.com：</code></p><pre class="line-numbers language-none"><code class="language-none">https://hackerone.com/zendesk_session?locale_id=1&amp;return_to=https://support.hackerone.com/ping/redirect_to_account?state = compayn:/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于该链接包含域hackerone.com，因此插页式网页不会显示，并且用户不会知道所访问的网页是不安全的。有趣的是，Jamal最初将缺失的插页式页面重定向问题报告给了Zendesk，但它被忽略且未标记为漏洞。他不断挖掘以寻找如何利用缺失的插页式广告。最终，他发现了JavaScript重定向攻击，使HackerOne付了赏金。</p><p><strong>重点</strong></p><p>搜索漏洞时，请注意站点使用的服务，因为每个服务都代表新的攻击媒介。通过结合HackerOne对Zendesk的使用和已知的HackerOne允许的重定向，可以使此HackerOne漏洞成为可能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开放重定向允许恶意攻击者在不知不觉中将用户重定向到恶意网站。从示例漏洞报告中了解到，找到它们通常需要敏锐的观察。如示例中所述，当重定向参数具有诸如redirect_to =，domain_name =或checkout_url =之类的名称时，有时很容易发现。其他时候，它们的名称可能不太明显，例如r =，u =等。</p><p>开放重定向漏洞依赖于滥用信任，即诱使目标用户以为攻击者正在访问他们认识的网站，同时诱使他们访问攻击者的网站。当发现可能的易受攻击的参数时，如果URL的某些部分经过硬编码，请确保对其进行彻底测试并添加特殊字符。</p><p>HackerOne插页式重定向显示了在寻找漏洞时识别网站使用的工具和服务的重要性。请记住，有时您需要保持执着，并清楚地表明一个说服公司接受您的发现并支付赏金的漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> Web Hacking 101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part1 漏洞挖掘基础知识</title>
      <link href="2020/10/13/part1-lou-dong-wa-jue-ji-chu-zhi-shi/"/>
      <url>2020/10/13/part1-lou-dong-wa-jue-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Part1-漏洞挖掘基础知识"><a href="#Part1-漏洞挖掘基础知识" class="headerlink" title="Part1 漏洞挖掘基础知识"></a><center>Part1 漏洞挖掘基础知识</center></h1><p><font color="#A52A2A" size="4"><em>本文部分翻译自Peter Yaworski的《Web Hacking 101》，仅供参考学习，切勿二传。</em></font></p><p>如果您是黑客新手，这篇文章可以让您对互联网的工作原理有一个基本了解，你会了解到当在浏览器的地址栏中输入URL时，幕后到底发生了什么。尽管导航到网站似乎很简单，但是它涉及许多隐藏的过程，例如准备HTTP请求，将请求发送目的地的域名，将域名转换为IP地址，发送请求，呈现响应等等。 </p><p>在本章中，您将学习基本概念和术语，例如漏洞，漏洞赏金，客户端，服务器，IP地址和HTTP。您将大致了解如何执行意外操作以及提供意外输入或对私人信息的访问会导致漏洞。然后，我们将看到在浏览器的地址栏中输入URL时会发生的情况，包括HTTP请求和响应以及各种HTTP操作。我们将在本章结束时了解HTTP是无状态的含义。</p><h2 id="漏洞和漏洞赏金"><a href="#漏洞和漏洞赏金" class="headerlink" title="漏洞和漏洞赏金"></a>漏洞和漏洞赏金</h2><p>漏洞是应用程序中的一个弱点，它使恶意程序可以执行某些未经许可的操作或访问他们不应该被允许访问的信息。</p><p>在学习和测试应用程序时，请记住，攻击者执行有意和无意的操作可能会导致漏洞。例如，更改记录标识符的ID以访问您不应该访问的信息就是一个无意操作的示例。</p><p>假设一个网站需要您使用您的姓名，电子邮件，生日和地址来创建个人资料。您的信息是保密的，且仅与您的朋友共享。但是，如果网站允许任何人未经您的允许将您加为好友，这将是一个漏洞。即使该网站使您的信息对非朋友而言都是私密的，但通过允许任何人将您添加为朋友，任何人都可以访问您的信息。在测试站点时，请始终考虑到会有人如何滥用现有功能。 </p><p>漏洞赏金是网站或公司对任何发现漏洞并将其报告给该网站或公司的人的奖励。奖励通常是金钱，范围从数万美元到数万美元不等。赏金的其他内容包括加密货币，航空里程，奖励积分，服务积分等。</p><p>当公司提供赏金悬赏时，它会创建一个“程序”，我们将在本书中使用该术语来表示公司为希望测试公司漏洞的人员所建立的规则和框架。请注意，这不同于运行漏洞披露程序（VDP）的公司。漏洞赏金会提供一些金钱奖励，而VDP则不提供付款。 VDP只是道德黑客向公司报告漏洞以使公司修复漏洞的一种方式。尽管本书中描述的报告中并非所有都得到了回报，但它们都是来自于参与漏洞赏金计划的黑客。</p><h2 id="客户端和服务器"><a href="#客户端和服务器" class="headerlink" title="客户端和服务器"></a>客户端和服务器</h2><p>您的浏览器依赖于Internet，Internet是相互发送消息的计算机网络。我们称这些消息为数据包。数据包包括您要发送的数据以及有关该数据的来源和去向的信息。互联网上的每台计算机都有一个向其发送数据包的地址。但是某些计算机只接受某些类型的数据包，而其他计算机仅允许其他计算机的受限列表中的数据包。然后由接收计算机决定如何处理数据包以及如何响应。就本书而言，我们将仅关注数据包（HTTP消息）中包含的数据，而不是数据包本身。</p><p>我将这些计算机称为客户端或服务器。无论请求是否由浏览器，命令行等发起，发起请求的通常都称为客户端。服务器是指接收请求的网站和Web应用程序。如果该概念适用于客户端或服务器，那么我一般指的是计算机。</p><p>因为Internet可以包括任意数量的相互通信的计算机，所以就需要有关计算机应如何通过Internet进行通信的特定准则。它使用了“<strong>Request for Comment</strong>（RFC）”文档的形式，该文档定义了计算机应如何运行的标准。例如，超文本传输协议（HTTP）定义Internet浏览器如何使用Internet协议（IP）与远程服务器通信。在这种情况下，客户端和服务器都必须同意实施相同的标准，以便他们可以理解各自正在发送和接收的数据包。</p><h2 id="您访问网站时会发生什么"><a href="#您访问网站时会发生什么" class="headerlink" title="您访问网站时会发生什么"></a>您访问网站时会发生什么</h2><p> 因为我们将在本书中重点介绍HTTP消息，所以本节为您提供了在浏览器的地址栏中输入URL时发生的过程的高度概述。</p><p><strong><em>步骤1：提取域名</em></strong></p><p>输入<code>http://www.google.com/</code>后，您的浏览器将从URL确定域名。域名用于标识您要访问的网站，并且必须遵守RFC定义的特定规则。例如，域名只能包含字母数字字符和下划线。国际化域名是一个例外，超出了本书的范围。要了解更多信息，请参阅RFC 3490，其中定义了它们的用法。在这种情况下，域名为<code>www.google.com</code>。域名是查找服务器地址的一种方法。</p><p><strong><em>步骤2：解析IP地址</em></strong></p><p>确定域名后，浏览器将使用IP查找与该域关联的IP地址。 此过程称为解析IP地址，并且Internet上的每个域都必须解析为IP地址才能正常工作。</p><p>存在两种类型的IP地址：Internet协议版本4（IPv4）和Internet协议版本6（IPv6）。 IPv4地址被构造为四个由句点连接的数字，每个数字的范围为0到255。IPv6是Internet协议的最新版本。 它旨在解决可用IPv4地址用尽的问题。 IPv6地址由冒号分隔的八组四个十六进制数字组成，但是存在一些缩短IPv6地址的方法。 例如，8.8.8.8是IPv4地址，而2001：4860：4860 :: 8888是缩短的IPv6地址。</p><p>要仅使用域名查找IP地址，您的计算机会向域名系统（DNS）服务器发送请求，该服务器由Internet上的专用服务器组成，这些服务器具有所有域及其匹配IP地址的注册表。前面的IPv4和IPv6地址是Google DNS服务器。</p><p>在此示例中，您连接的DNS服务器会将<code>www.google.com</code>与IPv4地址216.58.201.228匹配，然后将其发送回您的计算机。要了解有关网站IP地址的更多信息，可以从终端使用命令dig命令（linux）。</p><p><strong><em>步骤3：建立TCP连接</em></strong></p><p>接下来，由于您使用http：//访问站点，因此计算机尝试使用IP地址在端口80上建立传输控制协议（TCP）连接。 TCP的详细信息并不重要，除了要注意它是定义计算机相互通信方式的另一种协议。 TCP提供双向通信，因此消息接收者可以验证接收到的信息，并且传输过程中不会丢失任何信息。</p><p>您向其发送请求的服务器可能正在运行多个服务（将服务视为计算机程序），因此它使用端口来标识接收请求的特定进程。您可以将端口视为服务器通往互联网的大门。没有端口，服务将不得不竞争发送到同一位置的信息。这意味着我们需要另一个标准来定义服务之间的协作方式，并确保一项服务的数据不会被另一项窃取。例如，端口80是用于发送和接收未加密的HTTP请求的标准端口。另一个公共端口是443，用于加密的HTTPS请求。尽管端口80是HTTP的标准端口，而端口443是HTTPS的标准端口，但根据管理员配置应用程序的方式，TCP通信可以在任何端口上进行。</p><p>您可以通过打开终端并运行<code>nc &lt;IP ADDRESS&gt; 80</code>，在端口80上建立到网站的TCP连接。它使用Netcat实用程序的nc命令创建用于读取和写入消息的网络连接。</p><p><strong><em>步骤4：发送HTTP请求</em></strong></p><p>以<code>http://www.google.com/</code>为例，如果步骤3中的连接成功，则浏览器应准备并发送HTTP请求，如清单1-1所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">➊ GET / HTTP/1.1 ➋ Host: www.google.com ➌ Connection: keep-alive ➍ Accept: application/html, */* ➎ User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36   (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36  （KHTML，例如Gecko）Chrome / 72.0.3626.109 Safari / 537.36 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>代码list 1-1：发送一个HTTP请求</em></p><p>浏览器向/路径➊（该网站的根目录）发出GET请求。网站的内容是通过路径组织的，就像计算机上的文件夹和文件一样。当你想访问文件夹的下一级，您可以在文件夹的名称后跟一个/即可表示该文件的路径。当您访问网站的第一页时，您将访问根路径，即/。浏览器还表示它正在使用HTTP 1.1版协议。 GET请求仅检索信息。我们稍后将详细了解它。</p><p>Host头➋保存着额外的信息，它作为请求的一部分被发送。 HTTP 1.1需要它来识别给定IP地址的服务器应将请求发送到哪里，因为IP地址可以托管多个域名。Connection header➌表示保持与服务器的连接保持打开状态的请求，以避免不断打开和关闭连接的开销。</p><p>您可以在➍看到预期的响应格式。在这个例子，我们期望得到application / html格式。但正如通配符（* / *）所示，我们可以接受任何格式。内容类型虽然有数百种，但在这本书里，您会经常看到的是application / html，application / json，application / octet-stream和text / plain。最后，用户代理➎表示负责发送请求的软件。</p><p><strong><em>步骤5：服务器响应</em></strong></p><p>为了响应我们的请求，服务器会使用类似List 1-2进行响应：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">➊ HTTP/1.1 200 OK ➋ Content-Type: text/html   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>     ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Google.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  ​ ➌ --**snip**--    ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>   ​<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>List 1-2：服务器响应</em></p><p>在这里，我们收到了HTTP响应，其状态码为200➊，并已附加到HTTP / 1.1。状态码很重要，因为它指示服务器如何响应。这些代码也由RFC定义，通常具有以2、3、4或5开头的三位数字。尽管没有严格要求服务器使用特定代码，但是2xx代码通常表示请求成功。</p><p>因为没有严格执行服务器如何实现其HTTP代码使用的强制措施，所以即使HTTP消息正文说明存在应用程序错误，您也可能会看到某些应用程序以200响应。 HTTP消息主体是与请求或响应关联的内容。在这种情况下，由于Google的响应主体很大，因此我们删除了内容，并以–snip-替换。网页的响应内容通常是HTML，但对于应用程序编程接口的响应，则可以是JSON，对于文件下载，则可以是文件内容，等等。</p><p>Content-Type头➋告知浏览器主体的媒体类型。媒体类型确定浏览器如何呈现正文内容。但是浏览器并不总是使用应用程序返回的值。取而代之的是，浏览器执行MIME嗅探，读取正文内容的第一位以确定自己的媒体类型。应用程序可以通过包含X-Content-Type-Options：nosniff来禁用此浏览器行为，该标头未包含在前面的示例中。</p><p>其他以3开头的响应代码表示重定向，该重定向指示您的浏览器提出额外的请求。例如，如果Google从理论上讲需要将您从一个URL永久重定向到另一个URL，则可以使用301响应。而302是临时重定向。</p><p>收到3xx响应时，浏览器应向Location标头中定义的URL发出新的HTTP请求，如下所示：</p><p><code>HTTP/1.1 301 Found Location: https://www.google.com/</code></p><p>以4开头的响应通常表示用户错误，例如，尽管请求提供了有效的HTTP请求，但请求中并未包含用于授权访问内容的适当标识，则响应403。以5开头的响应标识某种类型的服务器错误，例如503，指示服务器无法处理发送的请求。</p><p><strong><em>步骤6：呈现响应</em></strong></p><p>由于服务器发送的响应内容的类型为text / html，状态码为200，因此我们的浏览器将开始呈现收到的内容。响应的主体告诉浏览器应向用户显示的内容。</p><p>对于我们的示例，这将包括用于页面结构的HTML；级联样式表（CSS），用于样式和布局；和JavaScript以添加其他动态功能和媒体，例如图像或视频。服务器有可能返回其他内容，例如XML。第11章将更详细地讨论XML。</p><p>由于网页可以引用外部文件（例如CSS，JavaScript和媒体），因此浏览器可能会针对网页的所有必需文件提出其他HTTP请求。当浏览器请求这些其他文件时，它将继续解析响应并将主体显示为网页。在这个例子，它将呈现Google的主页<code>www.google.com</code>。</p><p>请注意，JavaScript是每种主流浏览器都支持的脚本语言。 JavaScript使网页具有动态功能，包括能够在不重新加载网页的情况下更新网页上的内容，检查密码（在某些网站上）是否足够牢固等。与其他编程语言一样，JavaScript具有内置函数，可以将值存储在变量中，并响应网页上的事件运行代码。它还可以访问各种浏览器应用程序编程接口（API）。这些API使JavaScript能够与其他系统进行交互，其中最重要的可能是文档对象模型（DOM）。</p><p>DOM使JavaScript可以访问和操纵网页的HTML和CSS。这很重要，因为如果攻击者可以在网站上执行自己的JavaScript，他们将有权访问DOM并可以代表目标用户在网站上执行操作。第7章将进一步探讨该概念。</p><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>客户端和服务器之间关于如何处理HTTP消息的协议包括定义请求方法。请求方法指示客户端请求的目的以及客户端期望成功的结果。例如，List 1-1中，我们向<code>http://www.google.com/</code>发送了一个GET请求，这意味着我们期望仅返回<code>http://www.google.com/</code>的内容，而不会执行其他任何操作。由于Internet被设计为远程计算机之间的接口，因此开发并实现了请求方法以区分所调用的动作。</p><p>HTTP标准定义了以下请求方法：GET，HEAD，POST，PUT，DELETE，TRACE，CONNECT和OPTIONS（PATCH也被提出了，但在HTTP RFC中未实现）。在撰写本文时，浏览器仅使用HTML发送GET和POST请求。任何PUT，PATCH或DELETE请求都是JavaScript调用HTTP请求的结果。下一节简要概述了您在本书中可以找到的请求方法。</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>GET方法可以查找由请求统一资源标识符（URI）标识的任何信息。术语URI通常与统一资源定位符（URL）同义使用。从技术上讲，URL是URI的一种，它定义了一种资源，并包括一种通过其网络位置来定位该资源的方法。例如，<code>http://www.google.com/&lt;example&gt;/file.txt</code>和<code>/&lt;example&gt;/file.txt</code>是有效的URI。但是只有<code>http://www.google.com/&lt;example&gt;/file.txt</code>是有效的URL，因为它标识了如何通过域名<code>http://www.google.com</code>查找资源。尽管有细微差别，但在引用任何资源标识符时，我们都会在整本书中使用URL。</p><p>虽然无法强制执行此要求，但GET请求不应更改数据；他们应该只是从服务器检索数据并在HTTP消息主体中返回数据。例如，在社交媒体网站上，GET请求应返回您的个人资料名称，但不更新您的个人资料。对于第4章中讨论的跨站点请求伪造（CSRF）漏洞，GET至关重要。访问任何URL或网站链接（除非由JavaScript调用）都会导致您的浏览器将GET请求发送到目标服务器。此行为对于第2章中讨论的开放重定向漏洞至关重要。</p><p>HEAD方法与GET方法相同，除了前者服务器在响应中不会返回消息主体。</p><p>POST方法在接收服务器上调用由服务器确定的某些功能。换</p><p>句话说，通常将执行某种类型的后端操作，例如创建评论，注册用户，删除帐户等等。服务器为响应POST而执行的操作可能有所不同。有时，服务器可能根本不采取任何措施。例如，POST请求可能会导致在处理请求时发生错误，并且记录不会保存在服务器上。</p><p>PUT方法调用某些函数，该函数引用远程网站或应用程序上已经存在的记录。例如，当更新已经存在的帐户，博客帖子等时，可以使用它。同样，执行的操作可能会有所不同，并且可能导致服务器完全不执行任何操作。</p><p>DELETE方法请求远程服务器删除用URI标识的远程资源。</p><p>TRACE方法是另一种不常用的方法。它用于将请求消息反射回请求者。它允许请求者查看服务器正在接收的内容，并将该信息用于测试和收集诊断信息。</p><p>CONNECT方法保留给代理使用，代理是将请求转发到其他服务器的服务器。此方法使用请求的资源启动双向通信。例如，CONNECT方法可以通过代理访问使用HTTPS的网站。</p><p>OPTIONS方法从服务器请求有关可用通信选项的信息。例如，通过调用OPTIONS，可以查明服务器是否接受GET，POST，PUT，DELETE和OPTIONS调用。此方法不会指示服务器是否接受HEAD或TRACE调用。浏览器会针对特定内容类型（例如application / json）自动发送此类请求。这种方法称为preflight OPTIONS调用，将在第4章中进行更深入的讨论，因为它用作CSRF漏洞保护。</p><h3 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h3><p>HTTP请求是无状态的，这意味着发送到服务器的每个请求都被视为全新请求。收到请求时，服务器对其先前与浏览器的通信一无所知。这对于大多数站点都是有问题的，因为这些站点想记住您是谁。否则，您必须为每个发送的HTTP请求重新输入用户名和密码。这也意味着，必须将客户端发送给服务器的每个请求中的所有数据重新加载，以处理HTTP请求。为避免每次HTTP请求都必须重新发送用户名和密码，网站使用Cookie或基本身份验证。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>您现在应该对互联网的工作原理有基本的了解。 具体来说，您学习了在浏览器的地址栏中输入网站时发生的情况：浏览器如何将其转换为域，域如何映射到IP地址以及HTTP请求如何发送到服务器。</p><p>您还学习了浏览器如何构造请求和呈现响应以及HTTP请求方法如何允许客户端与服务器进行通信。 此外，您还了解到，漏洞是由某人执行意外操作或获得对原本不可用的信息的访问所导致的，而漏洞赏金是从道德上发现漏洞并向网站所有者报告漏洞的奖励。</p>]]></content>
      
      
      <categories>
          
          <category> Web Hacking 101 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
